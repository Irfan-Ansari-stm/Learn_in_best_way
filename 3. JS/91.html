<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>26.2 Global State Management — Deep Learning Note</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">

  <style>
    :root{
      --bg:#0b0f11;
      --surface:#121416;
      --accent-cyan:#06b6d4;
      --accent-amber:#f59e0b;
      --muted:#9aa6a6;
      --panel-width:340px;
      --radius:14px;
    }
    html,body{height:100%;background:var(--bg);color:#e6f3f3;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;margin:0}
    .app{display:grid;grid-template-columns:var(--panel-width) 1fr;gap:18px;padding:20px;height:100vh;box-sizing:border-box}
    .left-panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:var(--radius);padding:18px;position:relative;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    .right-panel{background:var(--surface);border-radius:var(--radius);padding:28px;overflow:auto;height:calc(100vh - 40px);box-shadow: 0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    .left-fixed{position:sticky;top:20px}
    .title{font-size:18px;font-weight:700;color:white}
    .subtitle{color:var(--muted);font-size:13px;margin-top:6px}
    .meta{margin-top:12px;font-size:13px}
    .toc-search{display:flex;gap:8px;margin-top:12px}
    .toc-list{margin-top:12px}
    .toc-item{padding:8px;border-radius:10px;margin-bottom:6px}
    .toc-item:hover{background:rgba(255,255,255,0.02)}
    .controls{display:flex;gap:8px;margin-top:12px}
    h1,h2,h3{color:#fff}
    h1{font-size:24px} h2{font-size:20px} h3{font-size:16px}
    p{line-height:1.6;color:#dbeaea}
    details{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.02)}
    summary{cursor:pointer;font-weight:600}
    pre{background:rgba(0,0,0,0.6);padding:12px;border-radius:10px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;font-size:13px}
    .section{scroll-margin-top:48px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg, rgba(6,182,212,0.08), rgba(245,158,11,0.06));font-size:13px}
    @media (max-width:900px){.app{grid-template-columns:1fr}.left-panel{order:2}.right-panel{order:1;height:auto}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left-panel left-fixed" aria-labelledby="toc-title">
      <div class="title">26.2 Global State Management</div>
      <div class="subtitle">Redux, MobX, Zustand, Context API, State Machines (JS)</div>
      <div class="meta">
        <div><span class="pill">Author:</span> Deep Tutor</div>
        <div class="muted" style="margin-top:6px">Designed for college → PhD level: deep and details details details</div>
      </div>

      <div class="toc-search">
        <input id="tocFilter" class="form-control form-control-sm" placeholder="Search TOC, e.g. reducer" aria-label="search toc">
        <button id="expandAllBtn" class="btn btn-sm btn-outline-light" title="Expand all TOC">Expand</button>
      </div>

      <div class="controls">
        <button id="collapseAllBtn" class="btn btn-sm btn-outline-light">Collapse</button>
        <button id="topBtn" class="btn btn-sm btn-outline-light" onclick="document.querySelector('.right-panel').scrollTo({top:0, behavior:'smooth'})">Top</button>
      </div>

      <nav class="toc-list" id="tocList">
        <details class="toc-item open"><summary>Overview & Executive Summary</summary>
          <ul>
            <li><a href="#overview">What is Global State?</a></li>
            <li><a href="#redux">Redux Pattern & Principles</a></li>
            <li><a href="#mobx">MobX for Reactive State</a></li>
            <li><a href="#zustand">Zustand for Simple State</a></li>
            <li><a href="#context">Context API Patterns</a></li>
            <li><a href="#statemachine">State Machine Concepts</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Sections</summary>
          <ul>
            <li><a href="#redux">Redux</a></li>
            <li><a href="#mobx">MobX</a></li>
            <li><a href="#zustand">Zustand</a></li>
            <li><a href="#context">Context API</a></li>
            <li><a href="#statemachine">State Machines</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Examples & Code Snippets</summary>
          <ul>
            <li><a href="#example-redux">Redux Example</a></li>
            <li><a href="#example-mobx">MobX Example</a></li>
            <li><a href="#example-zustand">Zustand Example</a></li>
            <li><a href="#example-context">Context API Example</a></li>
            <li><a href="#example-xstate">XState Example</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Further Reading</summary>
          <ul>
            <li><a href="#further">Notes & Links</a></li>
          </ul>
        </details>
      </nav>

      <div style="position:absolute;left:18px;bottom:18px;font-size:12px;color:var(--muted)">Tip: use search to filter headings</div>
    </aside>

    <main class="right-panel" role="main">
      <article>
        <header class="section" id="overview">
          <h1>26.2 Global State Management — Deep Note</h1>
          <p class="muted">A layered, framework-agnostic guide to global state patterns with practical examples in JavaScript. Each topic uses <code>&lt;details&gt;</code> sections: executive summary, deep dive, syntax/pseudocode, readable examples, and best practices.</p>
        </header>

        <section class="section" id="redux">
          <h2>Redux Pattern and Principles</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Redux enforces a single immutable store, pure reducers, and unidirectional data flow. Actions describe events, reducers compute next state, and middleware handles side effects (thunks, sagas).</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Core principles: single source of truth (one store), state is read-only (only change via actions), and changes are made with pure functions (reducers). Time-travel debugging, predictable state transitions, and devtools are strong benefits. For async effects, use middleware (redux-thunk, redux-saga, redux-observable).</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>// action
const ADD_TODO = 'ADD_TODO';
function addTodo(text){ return { type: ADD_TODO, payload: { text } }; }

// reducer
function todosReducer(state = [], action){
  switch(action.type){
    case ADD_TODO: return [...state, { id: Date.now(), text: action.payload.text }];
    default: return state;
  }
}

// store
const store = createStore(rootReducer, applyMiddleware(thunk));
</code></pre>
          </details>

          <details>
            <summary>Readable example (Redux Toolkit - recommended)</summary>
            <pre><code>// slice.js (RTK)
import { createSlice } from '@reduxjs/toolkit';

const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    add(state, action){ state.push({ id: Date.now(), text: action.payload }); },
    toggle(state, action){ const t = state.find(x =&gt; x.id === action.payload); if(t) t.done = !t.done; }
  }
});

export const { add, toggle } = todosSlice.actions;
export default todosSlice.reducer;
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Redux shines in large apps with complex state shape and when tooling (time-travel, devtools) matters. It can be verbose; prefer Redux Toolkit for concise code. Avoid using Redux for every state—local or UI-only state belongs elsewhere.</p>
          </details>
        </section>

        <section class="section" id="mobx">
          <h2>MobX for Reactive State</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>MobX uses observables and reactions: state is made observable, and computed values and observers automatically update when dependencies change. It's more imperative and less boilerplate-heavy than Redux.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>MobX tracks which observables are used by which reactions and ensures efficient updates. It embraces mutable state with transparent reactivity. Use decorators or makeAutoObservable in MobX 6+ to mark state as observable and actions for mutations.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>import { makeAutoObservable } from 'mobx';

class TodoStore {
  todos = [];
  constructor(){ makeAutoObservable(this); }
  add(text){ this.todos.push({ id: Date.now(), text }); }
  get unfinished(){ return this.todos.filter(t =&gt; !t.done); }
}
const store = new TodoStore();
</code></pre>
          </details>

          <details>
            <summary>Readable example</summary>
            <pre><code>// React observer component
import { observer } from 'mobx-react-lite';

const TodoList = observer(({store}) =&gt; (
  &lt;ul&gt;{store.todos.map(t =&gt; &lt;li key={t.id}&gt;{t.text}&lt;/li&gt;)}&lt;/ul&gt;
));
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>MobX is excellent for apps that benefit from simple, reactive patterns and minimal boilerplate. Be mindful of implicit dependencies—keep stores well-organized and avoid overusing global mutable state in ways that make reasoning hard.</p>
          </details>
        </section>

        <section class="section" id="zustand">
          <h2>Zustand for Simple State</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Zustand is a tiny, unopinionated React state library that uses hooks and shallow subscriptions. It offers a minimal API, great ergonomics, and works well for medium-sized apps.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Zustand creates a central store with selectors; components subscribe to slices of state using hooks, avoiding unnecessary re-renders. It supports middleware for persistence, devtools, and immer for immutable updates.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>import create from 'zustand';

const useStore = create(set =&gt; ({
  todos: [],
  add: (text) =&gt; set(state =&gt; ({ todos: [...state.todos, { id: Date.now(), text }] })),
}));

// usage
const add = useStore(state =&gt; state.add);
</code></pre>
          </details>

          <details>
            <summary>Readable example</summary>
            <pre><code>function Add(){
  const add = useStore(s =&gt; s.add);
  return &lt;button onClick={() =&gt; add('hi')}&gt;Add&lt;/button&gt;
}
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Zustand is perfect when you want a lightweight, hook-based store without boilerplate. It is not a silver bullet for highly structured state requiring complex reducers—choose based on team needs and app complexity.</p>
          </details>
        </section>

        <section class="section" id="context">
          <h2>Context API Patterns</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Context provides a way to pass data through the component tree without prop drilling. It's built into React and suitable for theme, locale, or simple shared state. Use selectors and memoization to avoid re-renders.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Context re-renders all consumers when provider value changes. To avoid wasted renders, split contexts by responsibility, memoize values, or use selector patterns with useContextSelector libraries. For complex state, combine Context with reducers or external stores.</p>
          </details>

          <details>
            <summary>Syntax & example</summary>
            <pre><code>const ThemeContext = React.createContext({ theme: 'dark' });

function App(){
  const [theme, setTheme] = useState('dark');
  const value = useMemo(() =&gt; ({ theme, setTheme }), [theme]);
  return &lt;ThemeContext.Provider value={value}&gt; &lt;Child /&gt; &lt;/ThemeContext.Provider&gt;;
}
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Context is best for low-frequency changes like theme or auth user object. Avoid putting rapidly changing data into context unless you use selectors. For large apps, prefer dedicated stores with fine-grained subscriptions.</p>
          </details>
        </section>

        <section class="section" id="statemachine">
          <h2>State Machine Concepts</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>State machines model application logic as finite states and transitions—leading to explicit, testable, and predictable flows. XState is a popular library implementing statecharts for complex UI/state orchestration.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>State machines enforce that the system is always in a defined state and that transitions are explicit. Statecharts extend machines with hierarchical states, parallel states, and guards—making them powerful for complex workflows like forms, authentication, and multi-step processes.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode (XState)</summary>
            <pre><code>import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: { on: { TOGGLE: 'active' } },
    active: { on: { TOGGLE: 'inactive' } }
  }
});
</code></pre>
          </details>

          <details>
            <summary>Readable example (React + XState)</summary>
            <pre><code>import { useMachine } from '@xstate/react';

function Toggle(){
  const [state, send] = useMachine(toggleMachine);
  return &lt;button onClick={() =&gt; send('TOGGLE')}&gt;{state.matches('active') ? 'On' : 'Off'}&lt;/button&gt;
}
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Use state machines for complex UI flows, multi-step forms, or when you need guarantees about valid transitions. They add conceptual overhead—use them where the benefit outweighs added complexity.</p>
          </details>
        </section>

        <section class="section" id="examples">
          <h2>Examples & Code Snippets</h2>

          <details open>
            <summary>Redux: async thunk example</summary>
            <pre><code>// using RTK
import { createAsyncThunk } from '@reduxjs/toolkit';
export const fetchUsers = createAsyncThunk('users/fetch', async () =&gt; { const r = await fetch('/api/users'); return r.json(); });
</code></pre>
          </details>

          <details>
            <summary>MobX: reaction example</summary>
            <pre><code>import { reaction } from 'mobx';
reaction(() =&gt; store.query, q =&gt; { store.search(q); });
</code></pre>
          </details>

          <details>
            <summary>Zustand: middleware example</summary>
            <pre><code>import create from 'zustand';
import { devtools, persist } from 'zustand/middleware';

const useStore = create(devtools(persist(set =&gt; ({ count:0, inc:() =&gt; set(s =&gt; ({ count: s.count +1 })) }))));
</code></pre>
          </details>

          <details>
            <summary>Context + reducer example</summary>
            <pre><code>const StateContext = React.createContext(null);
function reducer(state, action){ switch(action.type){ case 'inc': return { ...state, count: state.count+1 }; default: return state; } }

function Provider({children}){ const [s, dispatch] = useReducer(reducer, {count:0}); return &lt;StateContext.Provider value={{s,dispatch}}&gt;{children}&lt;/StateContext.Provider&gt; }
</code></pre>
          </details>

          <details>
            <summary>XState: guard & actions</summary>
            <pre><code>const machine = createMachine({ states:{ idle:{ on:{ SUBMIT: [{ cond:'valid', target:'submitting' }, { target:'error' }] } } } }, { guards:{ valid:(ctx,evt)=> /* check */ true } });
</code></pre>
          </details>
        </section>

        <section class="section" id="further">
          <h2>Further Reading & Resources</h2>
          <ul>
            <li>Redux docs & Redux Toolkit — patterns and best practices.</li>
            <li>MobX docs — observable patterns and performance considerations.</li>
            <li>Zustand, Jotai — lightweight state libraries.</li>
            <li>XState docs — statecharts and modelling complex flows.</li>
          </ul>
        </section>

        <footer style="margin-top:24px;color:var(--muted)">
          <small>Generated learning note — global state management, single-file HTML. Ask to expand any section (TypeScript examples, server state integration, caching strategies, optimistic updates, or migration guides).</small>
        </footer>
      </article>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded',() =&gt; {
      document.querySelectorAll('pre code').forEach((el) =&gt; { try{ hljs.highlightElement(el); }catch(e){} });
      const filter = document.getElementById('tocFilter');
      filter.addEventListener('input', (e) =&gt; {
        const q = e.target.value.toLowerCase();
        document.querySelectorAll('#tocList details').forEach(d =&gt; { const text = d.textContent.toLowerCase(); d.style.display = text.includes(q) ? '' : 'none'; });
      });
      document.getElementById('expandAllBtn').addEventListener('click', () =&gt; { document.querySelectorAll('#tocList details').forEach(d =&gt; d.open = true); });
      document.getElementById('collapseAllBtn').addEventListener('click', () =&gt; { document.querySelectorAll('#tocList details').forEach(d =&gt; d.open = false); });
      document.querySelectorAll('a[href^="#"]').forEach(a =&gt; { a.addEventListener('click', (e) =&gt; { const href = a.getAttribute('href'); const target = document.querySelector(href); if(target){ e.preventDefault(); document.querySelector('.right-panel').scrollTo({top: target.offsetTop - 12, behavior:'smooth'}); } }); });
      const rp = document.querySelector('.right-panel'); rp.tabIndex = 0;
      const obs = new MutationObserver(() =&gt; { document.querySelectorAll('pre code').forEach((el) =&gt; { try { hljs.highlightElement(el); } catch(e){} }); });
      obs.observe(document.body, {childList:true, subtree:true});
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>