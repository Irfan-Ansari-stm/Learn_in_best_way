<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>18.1 Storage APIs — localStorage, IndexedDB, Cache API</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <style>
    :root{
      --bg:#0d1117; --surface:#0f1724; --muted:#9ca3af; --cyan:#06b6d4; --amber:#f59e0b; --panel-width:360px; --radius:12px; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
    }
    html,body{height:100%;background:var(--bg);color:#e6eef6;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;margin:0}
    .app{display:flex;height:100vh;gap:20px;padding:20px;box-sizing:border-box}
    .left{width:var(--panel-width);min-width:260px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:var(--radius);padding:18px;box-shadow:0 6px 18px rgba(2,6,23,0.7);position:sticky;top:20px;height:calc(100vh - 40px);overflow:auto}
    .right{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:var(--radius);padding:28px;box-shadow:0 6px 18px rgba(2,6,23,0.7);height:calc(100vh - 40px);overflow:auto}
    h1,h2,h3{color:#fff}
    .muted{color:var(--muted)}
    .toc-search{display:flex;gap:8px;margin-bottom:12px}
    .toc-list{list-style:none;padding:0;margin:0}
    .toc-item{padding:8px 10px;border-radius:8px;cursor:pointer}
    .toc-item:hover{background:rgba(255,255,255,0.02)}
    pre{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;overflow:auto;font-family:var(--mono);font-size:13px}
    code{font-family:var(--mono);font-size:13px}
    details{background:rgba(255,255,255,0.01);margin:10px 0;padding:10px;border-radius:8px}
    details[open]{box-shadow:0 8px 24px rgba(2,6,23,0.7)}
    summary{cursor:pointer;outline:none;padding:6px 8px;border-radius:6px}
    summary::-webkit-details-marker{display:none}
    .summary-title{display:flex;align-items:center;gap:10px}
    .pill{padding:2px 8px;border-radius:999px;background:rgba(245,158,11,0.12);color:var(--amber);font-size:12px}
    .section{padding-top:8px;margin-top:8px;border-top:1px dashed rgba(255,255,255,0.03)}
    .highlight{background:linear-gradient(90deg, rgba(6,182,212,0.06), transparent);}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    @media (max-width:900px){.app{flex-direction:column;padding:12px}.left{width:100%;position:relative;height:auto}.right{height:auto}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left">
      <div class="d-flex align-items-start mb-3">
        <div>
          <h4 class="mb-0">18.1 Storage APIs</h4>
          <div class="muted">Web Storage, IndexedDB, Cache API — JavaScript</div>
          <div class="mt-2"><small class="muted">Author: Advanced JS Tutor • Updated: Nov 28, 2025</small></div>
        </div>
      </div>

      <div class="toc-search">
        <input id="tocSearch" class="form-control form-control-sm" placeholder="Search TOC..." aria-label="Search table of contents"/>
        <button id="tocClear" class="btn btn-sm btn-outline-secondary">Clear</button>
      </div>

      <div class="controls">
        <button id="expandAll" class="btn btn-sm btn-primary">Expand all</button>
        <button id="collapseAll" class="btn btn-sm btn-ghost">Collapse all</button>
        <button id="tocCollapse" class="btn btn-sm btn-ghost">Collapse TOC</button>
      </div>

      <nav>
        <ul id="tocList" class="toc-list">
          <li class="toc-item" data-target="intro">Introduction &amp; Executive Summary</li>
          <li class="toc-item" data-target="webstorage">localStorage &amp; sessionStorage</li>
          <li class="toc-item" data-target="indexeddb">IndexedDB — complex structured storage</li>
          <li class="toc-item" data-target="cacheapi">Cache API — for offline resources</li>
          <li class="toc-item" data-target="quotas">Storage Quotas &amp; Management</li>
          <li class="toc-item" data-target="patterns">Patterns, Migration &amp; Security</li>
          <li class="toc-item" data-target="examples">Hands-on Examples</li>
          <li class="toc-item" data-target="cheatsheet">Cheat Sheet &amp; Checklist</li>
        </ul>
      </nav>
    </aside>

    <main class="right" id="content">
      <section id="intro" class="section">
        <h2>Introduction &amp; Executive Summary <span class="pill">Quick</span></h2>
        <details open>
          <summary><div class="summary-title"><strong>Executive summary</strong><span class="muted">(short)</span></div></summary>
          <div class="mt-2 muted">This module explains browser storage options: <strong>localStorage</strong> and <strong>sessionStorage</strong> for simple key-value needs; <strong>IndexedDB</strong> for large, structured, transactional storage; and the <strong>Cache API</strong> for storing request/response pairs for offline-first apps. We'll cover APIs, performance trade-offs, quotas, patterns for migration, and practical examples.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Why this matters</strong></div></summary>
          <div class="mt-2">Choosing the right storage API affects app responsiveness, offline behavior, and data integrity. Using localStorage for large data or blocking operations can freeze the main thread; using IndexedDB incorrectly can cause complexity or leaks. We'll go deep on when and how to use each API safely and performantly.</div>
        </details>
      </section>

      <section id="webstorage" class="section">
        <h3>localStorage &amp; sessionStorage</h3>

        <details>
          <summary><div class="summary-title"><strong>What &amp; Characteristics</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li><strong>localStorage</strong>: persistent, origin-scoped, synchronous, simple string key-value store (approx 5–10MB per origin in many browsers).</li>
              <li><strong>sessionStorage</strong>: same as localStorage but scoped to a single tab/window session and cleared when the session ends.</li>
              <li>Both are synchronous — reads/writes block the main thread.</li>
            </ul>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>API &amp; usage</strong></div></summary>
          <div class="mt-2">Always serialize complex data with <code>JSON.stringify</code> and parse on read. Avoid storing large blobs or binary data. Keep operations minimal to prevent blocking the UI.</div>
          <pre><code>&lt;!-- localStorage usage --&gt;
// store
localStorage.setItem('prefs', JSON.stringify({ theme: 'dark', fontSize: 14 }));
// read
const prefs = JSON.parse(localStorage.getItem('prefs') || '{}');
// remove
localStorage.removeItem('prefs');

// sessionStorage similar:
sessionStorage.setItem('draft', 'in-progress');
</code></pre>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Best practices &amp; pitfalls</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li>Don't store large datasets (will block UI).</li>
              <li>Prefer IndexedDB for binary/blob or large JSON data.</li>
              <li>Handle <code>null</code> returns and JSON parse errors defensively.</li>
              <li>Remember localStorage is synchronous — wrap heavy work in a Web Worker if necessary.</li>
            </ul>
          </div>
        </details>
      </section>

      <section id="indexeddb" class="section">
        <h3>IndexedDB</h3>

        <details>
          <summary><div class="summary-title"><strong>What &amp; when to use</strong></div></summary>
          <div class="mt-2">IndexedDB is a transactional, asynchronous NoSQL-like database built into browsers. Use it for large datasets, structured data, indexes, and storing Blobs or files. It operates off the main thread when used via the async APIs, so it's suitable for heavy storage without blocking UI.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Core concepts</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li><strong>Databases</strong> contain <strong>object stores</strong> (like tables).</li>
              <li><strong>Transactions</strong> are required to read/write; they offer atomicity for operations within their scope.</li>
              <li><strong>Key paths</strong> and <strong>indexes</strong> enable fast lookups.</li>
            </ul>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Vanilla IndexedDB example (promisified)</strong></div></summary>
          <div class="mt-2">This example shows a small helper that opens a DB, creates an object store, and provides simple CRUD operations. We wrap the callback API with Promises for ergonomics.</div>
          <pre><code>&lt;!-- idb-helper.js --&gt;
function openDB(name = 'app-db', version = 1){
  return new Promise((resolve, reject) =&gt; {
    const req = indexedDB.open(name, version);
    req.onupgradeneeded = (ev) =&gt; {
      const db = ev.target.result;
      if(!db.objectStoreNames.contains('notes')){
        const store = db.createObjectStore('notes', { keyPath: 'id', autoIncrement: true });
        store.createIndex('by_date', 'updatedAt');
      }
    };
    req.onsuccess = () =&gt; resolve(req.result);
    req.onerror = () =&gt; reject(req.error);
  });
}

async function addNote(db, note){
  return new Promise((resolve, reject) =&gt; {
    const tx = db.transaction('notes', 'readwrite');
    const store = tx.objectStore('notes');
    const req = store.add(note);
    req.onsuccess = () =&gt; resolve(req.result);
    req.onerror = () =&gt; reject(req.error);
  });
}

// usage:
(async ()=>{
  const db = await openDB();
  const id = await addNote(db, { title: 'Hello', content: 'IndexedDB rules', updatedAt: Date.now() });
  console.log('note id', id);
})();
</code></pre>

        </details>

        <details>
          <summary><div class="summary-title"><strong>Using idb library for ergonomics</strong></div></summary>
          <div class="mt-2">Libraries like <code>idb</code> (Jake Archibald) wrap IndexedDB in a clean promise-based API and are recommended for production apps. They reduce boilerplate and edge-case bugs.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Performance tips</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li>Batch writes inside a single transaction whenever possible.</li>
              <li>Avoid opening/closing databases frequently — reuse connections.</li>
              <li>Use indexes for queries you'd run often.</li>
              <li>Measure using Chrome DevTools > Application > IndexedDB.</li>
            </ul>
          </div>
        </details>
      </section>

      <section id="cacheapi" class="section">
        <h3>Cache API</h3>

        <details>
          <summary><div class="summary-title"><strong>What it is</strong></div></summary>
          <div class="mt-2">The Cache API stores request/response pairs (like a key-value store for network resources). It's commonly used with Service Workers to implement offline-first behavior and fine-grained caching strategies (cache-first, network-first, stale-while-revalidate).</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Basic usage</strong></div></summary>
          <div class="mt-2">Open a named cache, add resources, match requests, and delete entries. Note: Cache stores cloned responses — reading a response body consumes its stream unless cloned.</div>
          <pre><code>// example: simple cache usage inside a service worker
self.addEventListener('install', (ev) =&gt; {
  ev.waitUntil(
    caches.open('v1').then(cache =&gt; cache.addAll([
      '/', '/index.html', '/styles.css', '/app.js'
    ]))
  );
});

self.addEventListener('fetch', (ev) =&gt; {
  ev.respondWith(
    caches.match(ev.request).then(cached =&gt; cached || fetch(ev.request))
  );
});
</code></pre>

        </details>

        <details>
          <summary><div class="summary-title"><strong>Strategies</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li><strong>Cache-first</strong>: return cached response, fallback to network. Good for assets that rarely change.</li>
              <li><strong>Network-first</strong>: try network, fallback to cache. Good for fresh content (e.g., API responses) with offline fallback.</li>
              <li><strong>Stale-while-revalidate</strong>: return cached immediately, then update cache in background.</li>
            </ul>
          </div>
        </details>
      </section>

      <section id="quotas" class="section">
        <h3>Storage Quotas &amp; Management</h3>

        <details>
          <summary><div class="summary-title"><strong>Quotas overview</strong></div></summary>
          <div class="mt-2">Storage quotas vary by browser and device. localStorage typically ~5MB; IndexedDB &amp; Cache API quotas are larger and often dynamic (percent of disk). The Quota Management API (<code>navigator.storage.estimate()</code>) provides estimates of usage and quota.</div>
          <pre><code>// usage estimate
(async ()=>{
  if(navigator.storage && navigator.storage.estimate){
    const quota = await navigator.storage.estimate();
    console.log('usage', quota.usage, 'quota', quota.quota);
  }
})();
</code></pre>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Management tips</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li>Use <code>navigator.storage.persist()</code> to request persistent storage (prevents eviction on some platforms).</li>
              <li>Gracefully handle quota-exceeded errors — shrink caches, delete old entries, or prompt users.</li>
              <li>Provide a storage settings UI to let users clear locally cached data.</li>
            </ul>
          </div>
        </details>
      </section>

      <section id="patterns" class="section">
        <h3>Patterns, Migration &amp; Security</h3>
        <details>
          <summary><div class="summary-title"><strong>Migration</strong></div></summary>
          <div class="mt-2">When migrating from localStorage to IndexedDB, consider a one-time migration step on first load: read legacy keys, transform to structured objects, write to IndexedDB, and remove legacy keys. Use a version flag in IndexedDB to track migration state.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Security considerations</strong></div></summary>
          <div class="mt-2">Never store secrets or sensitive tokens in localStorage — it's accessible to any script running on the origin and vulnerable to XSS. Prefer httpOnly cookies for auth tokens, and use short-lived tokens with proper CSRF protections.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Data integrity</strong></div></summary>
          <div class="mt-2">Use transactions in IndexedDB for atomic writes. Consider checksums or versioning for cached data and content hashing for cache-busting stable assets.</div>
        </details>
      </section>

      <section id="examples" class="section">
        <h3>Hands-on Examples</h3>

        <details>
          <summary><div class="summary-title"><strong>Example: small migration from localStorage to IndexedDB</strong></div></summary>
          <div class="mt-2">This shows a safe migration flow with feature detection and fallback.</div>
          <pre><code>// pseudo-code: migrateSettings()
async function migrateSettings(){
  if(!('indexedDB' in window)) return; // nothing to do
  const raw = localStorage.getItem('settings');
  if(!raw) return;
  try{
    const settings = JSON.parse(raw);
    const db = await openDB('app-db', 2); // ensure store exists
    await putSettings(db, settings); // function that writes to IndexedDB
    localStorage.removeItem('settings');
    console.log('migration complete');
  }catch(err){ console.error('migration failed', err); }
}
</code></pre>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Example: request cache with stale-while-revalidate</strong></div></summary>
          <div class="mt-2">Simple approach inside Service Worker fetch handler.</div>
          <pre><code>self.addEventListener('fetch', (ev) =&gt; {
  const url = new URL(ev.request.url);
  if(url.pathname.startsWith('/api/')){
    ev.respondWith((async ()=>{
      const cache = await caches.open('api-cache');
      const cached = await cache.match(ev.request);
      const network = fetch(ev.request).then(async res =&gt; { if(res.ok) await cache.put(ev.request, res.clone()); return res; }).catch(()=>null);
      return cached || (await network) || new Response(null, { status: 503 });
    })());
  }
});
</code></pre>
        </details>

      </section>

      <section id="cheatsheet" class="section">
        <h3>Cheat Sheet &amp; Checklist</h3>
        <ul>
          <li>Use <strong>localStorage</strong> for small, simple key-value (non-sensitive) data.</li>
          <li>Use <strong>sessionStorage</strong> for per-tab session state.</li>
          <li>Use <strong>IndexedDB</strong> for large, structured, and binary data; wrap with a promise-friendly library.</li>
          <li>Use <strong>Cache API</strong> for network resources and offline strategies.</li>
          <li>Check quotas with <code>navigator.storage.estimate()</code> and request persistence with <code>navigator.storage.persist()</code>.</li>
          <li>Never store secrets in localStorage; protect against XSS and validate user inputs.</li>
        </ul>
      </section>

      <footer class="mt-4 muted"><small>Designed for students from college to PhD. For framework-specific examples (React/Vue/Svelte), worker examples, or downloadable ZIP, ask and I'll add them. — Advanced JS Tutor</small></footer>
    </main>
  </div>

  <script>
    // TOC interactions, search, expand/collapse, tiny highlight
    document.querySelectorAll('.toc-item').forEach(item =&gt; {
      item.addEventListener('click', () =&gt; {
        const target = document.getElementById(item.dataset.target);
        if(target){
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          document.querySelectorAll('.section').forEach(s =&gt; s.classList.remove('highlight'));
          target.classList.add('highlight');
          setTimeout(() =&gt; target.classList.remove('highlight'), 1400);
        }
      });
    });

    const tocSearch = document.getElementById('tocSearch');
    const tocList = document.getElementById('tocList');
    tocSearch.addEventListener('input', (e) =&gt; {
      const q = e.target.value.trim().toLowerCase();
      Array.from(tocList.children).forEach(li =&gt; {
        const text = li.textContent.trim().toLowerCase();
        li.style.display = text.includes(q) ? '' : 'none';
      });
    });
    document.getElementById('tocClear').addEventListener('click', () =&gt; { tocSearch.value=''; tocSearch.dispatchEvent(new Event('input')); });

    function setAll(open){ document.querySelectorAll('main details').forEach(d =&gt; { d.open = open; }); }
    document.getElementById('expandAll').addEventListener('click', () =&gt; setAll(true));
    document.getElementById('collapseAll').addEventListener('click', () =&gt; setAll(false));

    document.getElementById('tocCollapse').addEventListener('click', () =&gt; {
      const left = document.querySelector('.left');
      if(left.style.width === '64px'){ left.style.width = getComputedStyle(document.documentElement).getPropertyValue('--panel-width'); }
      else { left.style.width = '64px'; }
    });

    // tiny syntax highlight: numbers/keywords and JSON-like strings
    (function tinyHighlight(){
      const codeBlocks = document.querySelectorAll('pre code');
      const numRE = /\b(\d+)\b/g;
      const kwRE = /\b(const|let|var|function|async|await|return|if|else|for|while|try|catch|new)\b/g;
      codeBlocks.forEach(cb =&gt; {
        let html = cb.innerHTML;
        html = html.replace(numRE, '<span style="color:var(--cyan)">$1</span>');
        html = html.replace(kwRE, '<span style="color:var(--amber)">$1</span>');
        cb.innerHTML = html;
      });
    })();
  </script>
</body>
</html>
