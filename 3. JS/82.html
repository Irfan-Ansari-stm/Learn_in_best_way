<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>24.1 Testing Fundamentals — Deep Learning Note</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">

  <style>
    :root{--bg:#0b0f10;--surface:#111518;--cyan:#06b6d4;--amber:#f59e0b;--muted:#9aa6a6;--panel-width:340px;--radius:12px}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef0}
    .app{display:flex;gap:18px;height:100vh;padding:20px}
    .left-panel{width:var(--panel-width);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.04));padding:18px;border-radius:var(--radius);position:sticky;top:20px;height:calc(100vh - 40px);flex-shrink:0;border:1px solid rgba(255,255,255,0.03)}
    .right-panel{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));padding:22px;border-radius:var(--radius);overflow:auto;box-shadow:0 6px 18px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.02)}
    .brand{display:flex;gap:12px;align-items:center}
    .brand-mark{width:46px;height:46px;border-radius:10px;background:linear-gradient(90deg,var(--cyan),var(--amber));display:flex;align-items:center;justify-content:center;color:#071018;font-weight:700}
    .title{font-weight:700}
    .subtitle{font-size:0.82rem;color:var(--muted)}
    .toc{margin-top:12px}
    .search{margin-bottom:10px}
    .controls{display:flex;gap:8px;margin-bottom:8px}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px}
    .toc-list{max-height:58vh;overflow:auto;padding-right:6px}
    a.toc-item{display:block;padding:8px;border-radius:8px;margin-bottom:6px;color:inherit;text-decoration:none}
    a.toc-item:hover{background:rgba(255,255,255,0.02);color:var(--cyan)}
    details{background:rgba(255,255,255,0.015);padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.02)}
    summary{cursor:pointer;font-weight:600}
    pre{background:rgba(0,0,0,0.35);padding:12px;border-radius:8px;overflow:auto}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,'Roboto Mono','Courier New',monospace}
    h1,h2,h3{color:#dff7fb}
    p{color:#cfe8ea}
    .muted{color:var(--muted)}
    table.table thead th{border-bottom:1px solid rgba(255,255,255,0.04)}
    @media (max-width:900px){.left-panel{display:none}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left-panel" aria-label="Table of contents">
      <div class="brand">
        <div class="brand-mark">24.1</div>
        <div>
          <div class="title">Testing Fundamentals</div>
          <div class="subtitle">Unit, integration, e2e, TDD, BDD, doubles & strategies</div>
        </div>
      </div>
      <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Author: <strong>Irfan</strong></div>
        <div style="background:linear-gradient(90deg,var(--cyan),rgba(0,0,0,0.12));padding:4px 8px;border-radius:999px;color:#021417;font-weight:700">Advanced</div>
      </div>

      <div class="toc">
        <input id="tocSearch" class="form-control search" placeholder="Search TOC..." />
        <div class="controls">
          <button class="btn-ghost" id="expandAll">Expand all</button>
          <button class="btn-ghost" id="collapseAll">Collapse all</button>
          <button class="btn-ghost" id="tocReset">Reset</button>
        </div>
        <div class="toc-list" id="tocList">
          <a class="toc-item" href="#types">Unit, Integration & E2E testing</a>
          <a class="toc-item" href="#tdd">Test-driven development (TDD)</a>
          <a class="toc-item" href="#bdd">Behavior-driven development (BDD)</a>
          <a class="toc-item" href="#pyramid">Testing pyramid & strategies</a>
          <a class="toc-item" href="#doubles">Test doubles & mocking</a>
          <a class="toc-item" href="#tools">Tools: Jest, Mocha, Playwright, Cypress</a>
          <a class="toc-item" href="#checklist">Checklist & best practices</a>
        </div>
      </div>
    </aside>

    <main class="right-panel" id="content" tabindex="0">
      <article>
        <h1 id="top">24.1 Testing Fundamentals — Deep Learning Note</h1>
        <p class="muted">A deep, practical guide to software testing: types of tests, methodologies (TDD/BDD), testing strategies, test doubles, and real-world patterns. Examples are presented as safe HTML code blocks with entities so they display correctly. Use the TOC to navigate.</p>

        <!-- TYPES -->
        <section id="types" class="anchor-target">
          <h2>Unit, Integration &amp; End-to-End (E2E) Testing</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Different test types serve different purposes: unit tests check small units in isolation; integration tests verify interactions between modules; E2E tests exercise the full stack from UI to backend. Balance speed, reliability, and coverage across these layers.</p>
          </details>

          <details>
            <summary>Unit testing: focus & example</summary>
            <p>Unit tests isolate a single function or class, use test doubles for dependencies, and should be fast and deterministic.</p>
            <pre><code class="language-javascript">// add.js
function add(a, b) { return a + b }
module.exports = add;

// add.test.js (Jest)
const add = require('./add');
test('adds numbers', () =&gt; { expect(add(1,2)).toBe(3); });
</code></pre>
          </details>

          <details>
            <summary>Integration testing: scope & example</summary>
            <p>Integration tests verify multiple components working together (e.g., service + database). Use test databases or test containers and keep tests reasonably fast.</p>
            <pre><code class="language-javascript">// userService.test.js (integration)
const request = require('supertest');
const app = require('../app');

describe('User API', () =&gt; {
  test('creates and fetches user', async () =&gt; {
    const res = await request(app).post('/users').send({ name: 'Irfan' });
    expect(res.status).toBe(201);
    const get = await request(app).get(`/users/${res.body.id}`);
    expect(get.body.name).toBe('Irfan');
  });
});
</code></pre>
          </details>

          <details>
            <summary>E2E testing: strategy & example</summary>
            <p>E2E tests simulate user interactions. They are slower and more brittle; run a small E2E suite on CI regularly and broader suites nightly.</p>
            <pre><code class="language-javascript">// Playwright example
const { test, expect } = require('@playwright/test');

test('homepage flow', async ({ page }) =&gt; {
  await page.goto('http://localhost:3000');
  await page.click('text=Login');
  await page.fill('input[name=email]', 'test@example.com');
  await page.click('button[type=submit]');
  await expect(page).toHaveURL('/dashboard');
});
</code></pre>
          </details>
        </section>

        <hr />

        <!-- TDD -->
        <section id="tdd" class="anchor-target">
          <h2>Test-driven Development (TDD)</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>TDD is a cycle: write a failing test, implement minimal code to pass, refactor. TDD encourages small, testable units and can improve design — but requires discipline and fast tests.</p>
          </details>

          <details>
            <summary>TDD cycle & example</summary>
            <ol>
              <li>Write a failing test that specifies desired behaviour.</li>
              <li>Implement the smallest change to make the test pass.</li>
              <li>Refactor to improve design while keeping tests green.</li>
            </ol>
            <pre><code class="language-javascript">// Step 1: write test (failing)
const { reverse } = require('./stringUtils');
test('reverses string', () =&gt; { expect(reverse('ab')).toBe('ba'); });

// Step 2: minimal implementation
function reverse(s){ return s.split('').reverse().join(''); }
module.exports = { reverse };
</code></pre>
          </details>

          <details>
            <summary>When TDD shines & when not</summary>
            <ul>
              <li>Good for algorithmic code, libraries, and areas where requirements are clear.</li>
              <li>Less effective for UI exploration or when external dependencies cause flakiness.</li>
            </ul>
          </details>
        </section>

        <hr />

        <!-- BDD -->
        <section id="bdd" class="anchor-target">
          <h2>Behavior-driven Development (BDD)</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>BDD extends TDD by focusing on behaviour and collaboration, using human-readable specifications (Given/When/Then). Tools like Cucumber or Jest + jest-cucumber map specifications to automated tests.</p>
          </details>

          <details>
            <summary>Example (jest-cucumber)</summary>
            <pre><code class="language-gherkin">Feature: Login
  Scenario: Successful login
    Given I am on the login page
    When I submit valid credentials
    Then I should be redirected to the dashboard
</code></pre>
            <pre><code class="language-javascript">// glue code (jest-cucumber)
const { defineFeature, loadFeature } = require('jest-cucumber');
const feature = loadFeature('./features/login.feature');

defineFeature(feature, test =&gt; {
  test('Successful login', ({ given, when, then }) =&gt; {
    given('I am on the login page', async () =&gt; { /* navigate */ });
    when('I submit valid credentials', async () =&gt; { /* fill & submit */ });
    then('I should be redirected to the dashboard', async () =&gt; { /* assert */ });
  });
});
</code></pre>
          </details>

          <details>
            <summary>BDD pros & cons</summary>
            <ul>
              <li>Improves communication between developers, QA and stakeholders.</li>
              <li>Can become heavy if scenarios are not well-maintained.</li>
            </ul>
          </details>
        </section>

        <hr />

        <!-- PYRAMID -->
        <section id="pyramid" class="anchor-target">
          <h2>Testing Pyramid & Strategies</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>The testing pyramid recommends many fast unit tests at the base, fewer integration tests, and even fewer E2E tests at the top. This balances speed and confidence.</p>
          </details>

          <details>
            <summary>Practical interpretation</summary>
            <ul>
              <li>Unit tests: 70% of tests — fast, isolated.</li>
              <li>Integration tests: 20% — verify module interactions.</li>
              <li>E2E tests: 10% — user flows; slow but high confidence.</li>
            </ul>
            <p>Adjust proportions depending on the product and risk profile.</p>
          </details>

          <details>
            <summary>Anti-patterns to avoid</summary>
            <ul>
              <li>Having most tests be slow E2E tests — leads to slow feedback and flakiness.</li>
              <li>Over-mocking everything — hides integration issues.</li>
            </ul>
          </details>
        </section>

        <hr />

        <!-- DOUBLES -->
        <section id="doubles" class="anchor-target">
          <h2>Test Doubles &amp; Mocking</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Test doubles replace real dependencies to isolate tests. Types: dummy, fake, stub, spy, mock. Use doubles judiciously to control behaviour and verify interactions.</p>
          </details>

          <details>
            <summary>Definitions & example</summary>
            <ul>
              <li><strong>Dummy:</strong> placeholder object with no behaviour.</li>
              <li><strong>Fake:</strong> lightweight working implementation (e.g., in-memory DB).</li>
              <li><strong>Stub:</strong> provides canned responses.</li>
              <li><strong>Spy:</strong> records how a function was called.</li>
              <li><strong>Mock:</strong> pre-programmed expectations and verifications.</li>
            </ul>
            <pre><code class="language-javascript">// Jest spy example
const api = require('./api');
jest.spyOn(api, 'fetchUser').mockResolvedValue({ id: '1', name: 'Irfan' });

// assert it was called
expect(api.fetchUser).toHaveBeenCalledWith('1');
</code></pre>
          </details>

          <details>
            <summary>When to mock vs real integration</summary>
            <ul>
              <li>Mock external HTTP services and third-party SDKs for unit tests.</li>
              <li>Use fakes or test containers for databases in integration tests.</li>
              <li>Reserve E2E for real integration to validate end-to-end behaviour.</li>
            </ul>
          </details>
        </section>

        <hr />

        <!-- TOOLS -->
        <section id="tools" class="anchor-target">
          <h2>Tools &amp; Frameworks</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Popular test tools: Jest (unit/integration), Mocha+Chai (flexible), Playwright/Cypress (E2E), Sinon (mocks/fakes), Testcontainers (integration with containers). Choose based on team familiarity and ecosystem.</p>
          </details>

          <details>
            <summary>Jest example (setup & snapshot)</summary>
            <pre><code class="language-javascript">// package.json scripts
"test": "jest --coverage"

// snapshot test example
test('renders correctly', () =&gt; {
  const tree = renderer.create(&lt;MyComp /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});
</code></pre>
          </details>

          <details>
            <summary>Playwright vs Cypress</summary>
            <ul>
              <li>Playwright: multi-browser, powerful automation, good for E2E and API testing.</li>
              <li>Cypress: excellent developer experience, time-travel debugger, focused on Chrome-family browsers (now supports more via Cypress v10+).</li>
            </ul>
          </details>

          <details>
            <summary>Testcontainers for integration tests</summary>
            <pre><code class="language-javascript">const { GenericContainer } = require('testcontainers');
let container;
beforeAll(async () =&gt; { container = await new GenericContainer('postgres:13').start(); });
afterAll(() =&gt; container.stop());
</code></pre>
          </details>
        </section>

        <hr />

        <!-- CHECKLIST -->
        <section id="checklist" class="anchor-target">
          <h2>Checklist &amp; Best Practices</h2>

          <details open>
            <summary>Quick checklist before shipping</summary>
            <ul>
              <li>Fast unit tests with high coverage on critical modules.</li>
              <li>Integration tests for database and service contracts.</li>
              <li>Small E2E suite for critical user journeys.</li>
              <li>CI runs tests on PRs and prevents regressions.</li>
              <li>Use flakiness detection and retries sparingly.</li>
              <li>Measure test coverage but focus on meaningful assertions.</li>
            </ul>
          </details>

          <details>
            <summary>Performance & maintenance tips</summary>
            <ul>
              <li>Keep tests deterministic: seed RNG, isolate clocks, use fake timers cautiously.</li>
              <li>Parallelize tests where safe and use per-file setup/teardown to reduce global state.
</li>
              <li>Refactor tests when code changes to keep assertions clear and intentful.</li>
            </ul>
          </details>
        </section>

        <footer style="margin-top:20px;padding-bottom:40px;">
          <p class="muted">End of note. Use the left TOC to navigate and expand/collapse sections. If you want deeper examples — full Jest config, Playwright advanced patterns, or a sample CI test matrix — tell me which and I will extend this same file.</p>
        </footer>
      </article>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/javascript.min.js"></script>
  <script>
    if(window.hljs){ hljs.highlightAll(); }

    document.querySelectorAll('#tocList a').forEach(a=>{
      a.addEventListener('click', function(e){ e.preventDefault(); const id=this.getAttribute('href').slice(1); const el=document.getElementById(id); if(el){ el.scrollIntoView({behavior:'smooth',block:'start'}); const d=el.querySelector('details'); if(d && !d.open) d.open=true; } });
    });

    document.getElementById('expandAll').addEventListener('click', ()=> document.querySelectorAll('details').forEach(d=> d.open=true));
    document.getElementById('collapseAll').addEventListener('click', ()=> document.querySelectorAll('details').forEach(d=> d.open=false));
    document.getElementById('tocReset').addEventListener('click', ()=> document.getElementById('content').scrollTo({top:0,behavior:'smooth'}));

    document.getElementById('tocSearch').addEventListener('input', ()=>{ const q=document.getElementById('tocSearch').value.trim().toLowerCase(); document.querySelectorAll('#tocList a').forEach(a=>{ a.style.display = a.textContent.toLowerCase().includes(q) ? 'block' : 'none'; }); });

    document.addEventListener('keydown',(e)=>{ if(e.key==='E' || e.key==='e') document.querySelectorAll('details').forEach(d=> d.open=true); if(e.key==='C' || e.key==='c') document.querySelectorAll('details').forEach(d=> d.open=false); });
  </script>
</body>
</html>