<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>12.3 – Private Fields & Methods in JavaScript</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<style>
body{background:#050816;color:#e5e7eb;font-family:sans-serif;overflow:hidden;}
.sidebar{background:#07101f;border-right:1px solid #1f2933;height:100vh;overflow-y:auto;padding:20px;}
.content{height:100vh;overflow-y:auto;padding:30px;}
h1,h2,h3{color:#22d3ee;}
details{background:#0a1326;border:1px solid #234;padding:10px 15px;border-radius:10px;margin:10px 0;}
summary{cursor:pointer;color:#fbbf24;font-weight:600;}
pre{background:#020617;border:1px solid #0a7d7d;padding:10px;border-radius:10px;overflow-x:auto;}
code{color:#c3dafe;font-family:"JetBrains Mono", monospace;font-size:0.85rem;}
a{color:#9ca3af;text-decoration:none;}
a:hover{color:#22d3ee;}
button{background:none;border:1px solid #666;border-radius:20px;color:#aaa;font-size:0.75rem;padding:3px 10px;margin-right:4px;}
</style>
</head>

<body>
<div class="container-fluid">
<div class="row">

<!-- SIDEBAR -->
<div class="col-12 col-md-4 col-lg-3 sidebar">
<h3>12.3 – Private Fields & Methods</h3>
<p style="color:#9ca3af;">Deep technical mastery with modern JS encapsulation.</p>

<h5 style="color:#fbbf24;">On this page</h5>
<div class="toc">
<a href="#sec1">12.3.1 Private Fields (#field)</a>
<a href="#sec2">12.3.2 Private Methods</a>
<a href="#sec3">12.3.3 Static Private Members</a>
<a href="#sec4">12.3.4 Protected Pattern Simulation</a>
</div>

<button onclick="expandAll()">Expand all</button>
<button onclick="collapseAll()">Collapse all</button>
</div>

<!-- CONTENT -->
<div class="col content">

<h1>12.3 – Private Fields and Methods in JavaScript</h1>
<p>
Encapsulation is one of the foundational pillars of object-oriented programming.  
Modern JavaScript introduces *true* privacy via <code>#privateFields</code>, <code>#privateMethods</code> and <code>static #privateMembers</code>.  
These are enforced by the JavaScript engine at compile time — not runtime hacks or naming conventions.
</p>

<div style="background:#0a1a2d;border:1px solid #345;padding:15px;border-radius:10px;margin-bottom:20px;">
<b style="color:#fbbf24;">Executive intuition:</b><br>
Private fields exist in a hidden slot directly attached to the instance, not on <code>this</code> or the prototype.  
They cannot be accessed, modified, or enumerated externally.  
Unlike TypeScript “private”, this is *real* privacy enforced by the JavaScript engine.
</div>

<!-- ============================= -->
<!-- SECTION 1 – PRIVATE FIELDS    -->
<!-- ============================= -->
<section id="sec1">
<h2>12.3.1 Private Fields (#privateField)</h2>

<details open>
<summary>Concept: What is a private field?</summary>
<div>
<p>
A private field is declared using <code>#fieldName</code>.  
It is not accessible outside the class body — not even using bracket notation, not through inheritance, and not via prototypes.
</p>

<pre><code>
class BankAccount {
    #balance = 0; // private field

    constructor(owner, amount) {
        this.owner = owner;
        this.#balance = amount;
    }

    getBalance() {
        return this.#balance;
    }
}

const acc = new BankAccount("Irfan", 1000);
console.log(acc.getBalance()); // 1000
console.log(acc.#balance);     // ❌ SyntaxError
</code></pre>

<p><b>Key property:</b> Private fields are not part of the object's public keys.</p>
<pre><code>
console.log(Object.keys(acc)); // ["owner"]
</code></pre>

</div>
</details>

<details>
<summary>Internal technical behaviour</summary>
<div>
<p>
When you declare <code>#field</code>, the engine creates a hidden "private field storage" per instance.  
This storage cannot be interacted with using normal JS reflection.
</p>

<ul>
<li>Private fields do NOT live on <code>this</code>.</li>
<li>Private fields do NOT live on the prototype.</li>
<li>You cannot dynamically add or delete private fields.</li>
<li>Access is resolved statically during parsing.</li>
</ul>

<p>Invalid dynamic access:</p>

<pre><code>
const x = "#balance";
acc[x];         // ❌ doesn't work
acc["#balance"] // ❌ doesn't work
</code></pre>

</div>
</details>

<details>
<summary>Real example: Encapsulating sensitive data</summary>
<div>
<pre><code>
class User {
    #password;

    constructor(username, password) {
        this.username = username;
        this.#password = password;
    }

    verify(pwd) {
        return pwd === this.#password;
    }
}

const u = new User("Irfan", "12345");

console.log(u.verify("12345")); // true
console.log(u.#password);       // ❌ SyntaxError
</code></pre>
</div>
</details>

</section>

<!-- ============================= -->
<!-- SECTION 2 – PRIVATE METHODS   -->
<!-- ============================= -->
<section id="sec2">
<h2>12.3.2 Private Methods</h2>

<details open>
<summary>Concept: Why private methods?</summary>
<div>
<p>Private methods enable "internal logic" that outside code must not call, override, or depend on.</p>

<pre><code>
class Car {
    #startEngine() { console.log("engine started"); }

    drive() {
        this.#startEngine();
        console.log("driving...");
    }
}

new Car().drive(); // works
new Car().#startEngine(); // ❌ SyntaxError
</code></pre>

</div>
</details>

<details>
<summary>Private methods can also be async</summary>
<div>
<pre><code>
class Api {
    async #fetchData() {
        return fetch("/data").then(r =&gt; r.json());
    }

    async getData() {
        return await this.#fetchData();
    }
}
</code></pre>
</div>
</details>

<details>
<summary>Getter/setter with private methods</summary>
<div>
<pre><code>
class Thermostat {
    #celsius = 0;

    #toF(c){ return (c * 9/5) + 32; }

    get fahrenheit() { return this.#toF(this.#celsius); }

    set fahrenheit(f) { this.#celsius = (f - 32) * 5/9; }
}
</code></pre>
</div>
</details>

</section>

<!-- ================================ -->
<!-- SECTION 3 – STATIC PRIVATE MEMBERS -->
<!-- ================================ -->
<section id="sec3">
<h2>12.3.3 Static Private Members</h2>

<details open>
<summary>Static #private fields</summary>
<div>
<p>These belong to the class itself, not to instances.</p>

<pre><code>
class Counter {
    static #count = 0;

    constructor() {
        Counter.#count++;
    }

    static getCount() {
        return Counter.#count;
    }
}

new Counter();
new Counter();
console.log(Counter.getCount()); // 2
</code></pre>

</div>
</details>

<details>
<summary>Static private methods</summary>
<div>
<pre><code>
class Password {
    static #encrypt(str) {
        return str.split("").reverse().join("");
    }

    static store(rawPwd) {
        return Password.#encrypt(rawPwd);
    }
}

console.log(Password.store("Irfan")); // naf rI
Password.#encrypt("x"); // ❌ SyntaxError
</code></pre>
</div>
</details>

<details>
<summary>Important: Static private members cannot be accessed by instances</summary>
<div>
<pre><code>
class A {
    static #x = 10;
}

new A().#x; // ❌ invalid
</code></pre>
</div>
</details>

</section>

<!-- ========================================== -->
<!-- SECTION 4 – PROTECTED PATTERN SIMULATION  -->
<!-- ========================================== -->
<section id="sec4">
<h2>12.3.4 Protected Pattern Simulation</h2>

<details open>
<summary>JS has no native <code>protected</code>, but we can simulate it</summary>
<div>
<p>
Protected means: accessible inside class + subclasses, but not outside.  
JavaScript doesn't support this natively, but we can simulate it using:
</p>

<ul>
<li>Underscore naming convention (<code>_field</code>)</li>
<li>WeakMaps</li>
<li>Closures</li>
<li>Private fields with public wrappers</li>
</ul>

</div>
</details>

<details>
<summary>Pattern 1: WeakMap-based protected storage</summary>
<div>
<pre><code>
const _protected = new WeakMap();

class Base {
    constructor(){
        _protected.set(this, { secret: 42 });
    }

    getProtected(){
        return _protected.get(this).secret;
    }
}

class Child extends Base {
    revealSecret(){
        return _protected.get(this).secret;
    }
}

console.log(new Child().revealSecret()); // 42
</code></pre>

<p>Cannot be accessed outside the class tree.</p>
</div>
</details>

<details>
<summary>Pattern 2: Protected-like via method exposure</summary>
<div>
<pre><code>
class Parent {
    #internalData = "xyz";

    _getInternal(){   // protected-like
        return this.#internalData;
    }
}

class Child extends Parent {
    read(){
        return this._getInternal(); 
    }
}

console.log(new Child().read());
</code></pre>
<p>External code should not call <code>_getInternal()</code>, but subclasses may.</p>
</div>
</details>

<details>
<summary>Pattern 3: Closure-based protected scope</summary>
<div>
<pre><code>
function ProtectedClass() {
    let hidden = "abc";  // protected-like

    return class {
        get(){
            return hidden;
        }
        set(v){
            hidden = v;
        }
    };
}

const C = ProtectedClass();
const c1 = new C();
console.log(c1.get());
</code></pre>
</div>
</details>

</section>

</div>
</div>
</div>

<script>
function expandAll(){ document.querySelectorAll("details").forEach(d=>d.open=true); }
function collapseAll(){ document.querySelectorAll("details").forEach(d=>d.open=false); }
</script>

</body>
</html>
