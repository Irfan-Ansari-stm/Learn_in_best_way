<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>23.1 TypeScript Fundamentals — Deep Learning Note</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">

  <style>
    :root{--bg:#0b0f10;--surface:#111518;--cyan:#06b6d4;--amber:#f59e0b;--muted:#9aa6a6;--panel-width:340px;--radius:12px}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#e6eef0}
    .app{display:flex;gap:18px;height:100vh;padding:20px}
    .left-panel{width:var(--panel-width);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.04));padding:18px;border-radius:var(--radius);position:sticky;top:20px;height:calc(100vh - 40px);flex-shrink:0;border:1px solid rgba(255,255,255,0.03)}
    .right-panel{flex:1;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));padding:22px;border-radius:var(--radius);overflow:auto;box-shadow:0 6px 18px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.02)}
    .brand{display:flex;gap:12px;align-items:center}
    .brand-mark{width:46px;height:46px;border-radius:10px;background:linear-gradient(90deg,var(--cyan),var(--amber));display:flex;align-items:center;justify-content:center;color:#071018;font-weight:700}
    .title{font-weight:700}
    .subtitle{font-size:0.82rem;color:var(--muted)}
    .toc{margin-top:12px}
    .search{margin-bottom:10px}
    .controls{display:flex;gap:8px;margin-bottom:8px}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 8px;border-radius:8px}
    .toc-list{max-height:58vh;overflow:auto;padding-right:6px}
    a.toc-item{display:block;padding:8px;border-radius:8px;margin-bottom:6px;color:inherit;text-decoration:none}
    a.toc-item:hover{background:rgba(255,255,255,0.02);color:var(--cyan)}
    details{background:rgba(255,255,255,0.015);padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.02)}
    summary{cursor:pointer;font-weight:600}
    pre{background:rgba(0,0,0,0.35);padding:12px;border-radius:8px;overflow:auto}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,'Roboto Mono','Courier New',monospace}
    h1,h2,h3{color:#dff7fb}
    p{color:#cfe8ea}
    .muted{color:var(--muted)}
    @media (max-width:900px){.left-panel{display:none}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left-panel" aria-label="Table of contents">
      <div class="brand">
        <div class="brand-mark">23.1</div>
        <div>
          <div class="title">TypeScript Fundamentals</div>
          <div class="subtitle">Types, interfaces, generics, tsconfig, migration</div>
        </div>
      </div>
      <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center">
        <div class="muted">Author: <strong>Irfan</strong></div>
        <div style="background:linear-gradient(90deg,var(--cyan),rgba(0,0,0,0.12));padding:4px 8px;border-radius:999px;color:#021417;font-weight:700">Advanced</div>
      </div>

      <div class="toc">
        <input id="tocSearch" class="form-control search" placeholder="Search TOC..." />
        <div class="controls">
          <button class="btn-ghost" id="expandAll">Expand all</button>
          <button class="btn-ghost" id="collapseAll">Collapse all</button>
          <button class="btn-ghost" id="tocReset">Reset</button>
        </div>
        <div class="toc-list" id="tocList">
          <a class="toc-item" href="#annotations">Type annotations & inference</a>
          <a class="toc-item" href="#interfaces">Interfaces & type aliases</a>
          <a class="toc-item" href="#generics">Generics & advanced types</a>
          <a class="toc-item" href="#tsconfig">TypeScript configuration (tsconfig.json)</a>
          <a class="toc-item" href="#migration">Migration strategies from JavaScript</a>
          <a class="toc-item" href="#bestpractices">Best practices & checklist</a>
        </div>
      </div>
    </aside>

    <main class="right-panel" id="content" tabindex="0">
      <article>
        <h1 id="top">23.1 TypeScript Fundamentals — Deep Learning Note</h1>
        <p class="muted">A deep, example-rich note covering TypeScript's core concepts: annotations, inference, interfaces, generics, advanced types, config, and practical migration strategies. Code examples use HTML entities so they render correctly. Use the TOC to jump around.</p>

        <!-- ANNOTATIONS -->
        <section id="annotations" class="anchor-target">
          <h2>Type annotations &amp; type inference</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>TypeScript augments JavaScript with a static type system. You can annotate variables explicitly or rely on type inference. Type annotations improve tooling, catch errors early, and document intent.</p>
          </details>

          <details>
            <summary>Basic annotations & examples</summary>
            <pre><code class="language-typescript">// primitives
let count: number = 0;
let name: string = 'Irfan';
let active: boolean = true;

// arrays
const ids: number[] = [1, 2, 3];
const names: Array&lt;string&gt; = ['a','b'];

// function annotations
function add(a: number, b: number): number {
  return a + b;
}
</code></pre>
          </details>

          <details>
            <summary>Type inference</summary>
            <p>TypeScript infers types when you initialize variables or return from functions. Prefer inference for local variables and explicit annotations on public APIs.</p>
            <pre><code class="language-typescript">let x = 10; // inferred as number
const y = 'hello'; // inferred as 'hello' (string literal) or widened to string depending on context
function makePoint() { return { x: 0, y: 0 }; } // inferred return type: { x: number; y: number }
</code></pre>
          </details>

          <details>
            <summary>Any, unknown, never — when to use</summary>
            <ul>
              <li><code>any</code>: disables type checking — use sparingly.</li>
              <li><code>unknown</code>: safer alternative to <code>any</code> — must be narrowed before use.</li>
              <li><code>never</code>: denotes unreachable code (e.g., functions that always throw).</li>
            </ul>
            <pre><code class="language-typescript">let data: any;
let safe: unknown;

function fail(msg: string): never { throw new Error(msg); }
</code></pre>
          </details>
        </section>

        <hr />

        <!-- INTERFACES -->
        <section id="interfaces" class="anchor-target">
          <h2>Interfaces &amp; type aliases</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Interfaces and type aliases both create named types. Interfaces are best for object shapes and are extendable/mergeable; type aliases are more flexible (unions, mapped types) and can represent complex types.</p>
          </details>

          <details>
            <summary>Examples: interface vs type</summary>
            <pre><code class="language-typescript">// interface
interface User {
  id: number;
  name: string;
  email?: string; // optional
}

// type alias
type ID = number | string;

type ApiResponse&lt;T&gt; = {
  data: T;
  error?: string;
};
</code></pre>
          </details>

          <details>
            <summary>Extending and merging</summary>
            <pre><code class="language-typescript">interface Animal { name: string }
interface Dog extends Animal { bark(): void }

// declaration merging (interfaces)
interface Window { myApp?: any }
</code></pre>
          </details>

          <details>
            <summary>When to prefer one over the other</summary>
            <ul>
              <li>Use <code>interface</code> for public API shapes that may be extended.</li>
              <li>Use <code>type</code> for unions, tuples, and mapped/conditional types.</li>
            </ul>
          </details>
        </section>

        <hr />

        <!-- GENERICS -->
        <section id="generics" class="anchor-target">
          <h2>Generics &amp; advanced types</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Generics make types reusable and composable. Advanced types (mapped types, conditional types, keyof, infer) enable expressive static modeling akin to algebraic types in functional languages.</p>
          </details>

          <details>
            <summary>Basic generics</summary>
            <pre><code class="language-typescript">function identity&lt;T&gt;(value: T): T { return value; }
const s = identity&lt;string&gt;('hello');

// generic interfaces
interface Box&lt;T&gt; { value: T }
const box: Box&lt;number&gt; = { value: 10 };
</code></pre>
          </details>

          <details>
            <summary>Advanced types: keyof, mapped types, conditional types</summary>
            <pre><code class="language-typescript">type Keys = keyof User; // 'id' | 'name' | 'email'

type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] };

type Nullable&lt;T&gt; = { [K in keyof T]: T[K] | null };

type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;
</code></pre>
          </details>

          <details>
            <summary>Practical example: typed API client</summary>
            <pre><code class="language-typescript">// api.ts
async function fetchJson&lt;T&gt;(url: string): Promise&lt;T&gt; {
  const res = await fetch(url);
  if(!res.ok) throw new Error('Network error');
  return res.json() as Promise&lt;T&gt;;
}

// usage
type UserList = Array&lt;User&gt;;
const users = await fetchJson&lt;UserList&gt;('/api/users');
</code></pre>
          </details>
        </section>

        <hr />

        <!-- TSCONFIG -->
        <section id="tsconfig" class="anchor-target">
          <h2>TypeScript configuration (tsconfig.json)</h2>

          <details open>
            <summary>Executive summary</summary>
            <p><code>tsconfig.json</code> controls compiler options, module resolution, and project-wide behavior. Key options affect strictness, module target, JSX handling, and incremental builds.</p>
          </details>

          <details>
            <summary>Example config & explanations</summary>
            <pre><code class="language-json">{
  "compilerOptions": {
    "target": "ES2019",
    "module": "ESNext",
    "lib": ["DOM", "ES2019"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "outDir": "dist",
    "incremental": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
</code></pre>
            <p class="muted">Tips: enable <code>strict</code> for best safety. Use <code>noImplicitAny</code> and <code>strictNullChecks</code> to catch common JS pitfalls.</p>
          </details>

          <details>
            <summary>Project references & monorepos</summary>
            <p>Use <code>references</code> for multi-package TypeScript projects to enable faster incremental compilation and correct typing across packages in monorepos.</p>
          </details>
        </section>

        <hr />

        <!-- MIGRATION -->
        <section id="migration" class="anchor-target">
          <h2>Migration strategies from JavaScript</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Migrate gradually: add TypeScript to your build, enable <code>allowJs</code>, start with <code>checkJs</code> or <code>// @ts-check</code>, then convert files to <code>.ts/.tsx</code> progressively. Use <code>any</code> as a temporary escape hatch and add types incrementally.</p>
          </details>

          <details>
            <summary>Step-by-step migration plan</summary>
            <ol>
              <li>Install TypeScript and configure <code>tsconfig.json</code> with <code>allowJs: true</code>.</li>
              <li>Enable <code>noEmit</code> and run the type checker (<code>tsc --noEmit</code>) to find issues.</li>
              <li>Rename high-value modules to <code>.ts</code> and add explicit types for public APIs.</li>
              <li>Introduce <code>strict</code> slowly — enable one rule at a time (<code>noImplicitAny</code>, <code>strictNullChecks</code>).</li>
              <li>Use declaration files (<code>.d.ts</code>) for untyped third-party libs or JS modules.
            </ol>
          </details>

          <details>
            <summary>Example: incrementally adding types</summary>
            <pre><code class="language-javascript">// old: utils.js
module.exports.sum = (a, b) =&gt; a + b;

// new: utils.ts
export function sum(a: number, b: number): number { return a + b }
</code></pre>
          </details>

          <details>
            <summary>Tooling: ts-migrate, typesync, and community tips</summary>
            <p>Tools like <code>ts-migrate</code> (from Airbnb) and VSCode's quick fixes speed up bulk renames and type hints. Use community maintainer types (@types/*) for popular libraries.</p>
          </details>
        </section>

        <hr />

        <!-- BEST PRACTICES -->
        <section id="bestpractices" class="anchor-target">
          <h2>Best practices &amp; checklist</h2>

          <details open>
            <summary>Checklist for robust TypeScript projects</summary>
            <ul>
              <li>Enable <code>strict</code> and fix issues incrementally.</li>
              <li>Prefer <code>unknown</code> over <code>any</code> when accepting external data.</li>
              <li>Export well-typed public APIs; keep internal modules stricter.</li>
              <li>Use generics for reusable abstractions and avoid excessive type gymnastics that hurt readability.</li>
              <li>Provide <code>.d.ts</code> or <code>types</code> field for libraries.
            </ul>
          </details>

          <details>
            <summary>Further reading</summary>
            <ul>
              <li>TypeScript handbook, Advanced Types chapter</li>
              <li>Community posts on migration and patterns</li>
            </ul>
          </details>
        </section>

        <footer style="margin-top:20px;padding-bottom:40px;">
          <p class="muted">End of note. Use the left TOC to navigate and expand/collapse sections. If you want more: deep dives into conditional types, type-level programming, emitter patterns, or a full migration script and CI config — tell me which and I'll extend this same file.</p>
        </footer>
      </article>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/typescript.min.js"></script>
  <script>
    if(window.hljs){ hljs.highlightAll(); }

    document.querySelectorAll('#tocList a').forEach(a=>{
      a.addEventListener('click', function(e){ e.preventDefault(); const id=this.getAttribute('href').slice(1); const el=document.getElementById(id); if(el){ el.scrollIntoView({behavior:'smooth',block:'start'}); const d=el.querySelector('details'); if(d && !d.open) d.open=true; } });
    });

    document.getElementById('expandAll').addEventListener('click', ()=> document.querySelectorAll('details').forEach(d=> d.open=true));
    document.getElementById('collapseAll').addEventListener('click', ()=> document.querySelectorAll('details').forEach(d=> d.open=false));
    document.getElementById('tocReset').addEventListener('click', ()=> document.getElementById('content').scrollTo({top:0,behavior:'smooth'}));

    document.getElementById('tocSearch').addEventListener('input', ()=>{ const q=document.getElementById('tocSearch').value.trim().toLowerCase(); document.querySelectorAll('#tocList a').forEach(a=>{ a.style.display = a.textContent.toLowerCase().includes(q) ? 'block' : 'none'; }); });

    document.addEventListener('keydown',(e)=>{ if(e.key==='E' || e.key==='e') document.querySelectorAll('details').forEach(d=> d.open=true); if(e.key==='C' || e.key==='c') document.querySelectorAll('details').forEach(d=> d.open=false); });
  </script>
</body>
</html>