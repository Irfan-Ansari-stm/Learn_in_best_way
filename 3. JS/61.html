<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>18.2 Network APIs — Fetch, XHR, WebSocket, SSE & Interceptors</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <style>
    :root{--bg:#0d1117;--surface:#0f1724;--muted:#9ca3af;--cyan:#06b6d4;--amber:#f59e0b;--panel-width:360px;--radius:12px;--mono:ui-monospace,SFMono-Regular,Menlo,Monaco,'Roboto Mono','Courier New',monospace}
    html,body{height:100%;background:var(--bg);color:#e6eef6;font-family:Inter, system-ui, -apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;margin:0}
    .app{display:flex;height:100vh;gap:20px;padding:20px;box-sizing:border-box}
    .left{width:var(--panel-width);min-width:260px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:var(--radius);padding:18px;box-shadow:0 6px 18px rgba(2,6,23,0.7);position:sticky;top:20px;height:calc(100vh - 40px);overflow:auto}
    .right{flex:1;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:var(--radius);padding:28px;box-shadow:0 6px 18px rgba(2,6,23,0.7);height:calc(100vh - 40px);overflow:auto}
    h1,h2,h3{color:#fff}
    .muted{color:var(--muted)}
    .toc-search{display:flex;gap:8px;margin-bottom:12px}
    .toc-list{list-style:none;padding:0;margin:0}
    .toc-item{padding:8px 10px;border-radius:8px;cursor:pointer}
    .toc-item:hover{background:rgba(255,255,255,0.02)}
    pre{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;overflow:auto;font-family:var(--mono);font-size:13px}
    code{font-family:var(--mono);font-size:13px}
    details{background:rgba(255,255,255,0.01);margin:10px 0;padding:10px;border-radius:8px}
    details[open]{box-shadow:0 8px 24px rgba(2,6,23,0.7)}
    summary{cursor:pointer;outline:none;padding:6px 8px;border-radius:6px}
    summary::-webkit-details-marker{display:none}
    .summary-title{display:flex;align-items:center;gap:10px}
    .pill{padding:2px 8px;border-radius:999px;background:rgba(245,158,11,0.12);color:var(--amber);font-size:12px}
    .section{padding-top:8px;margin-top:8px;border-top:1px dashed rgba(255,255,255,0.03)}
    .highlight{background:linear-gradient(90deg, rgba(6,182,212,0.06), transparent);}
    .controls{display:flex;gap:8px;margin-bottom:12px}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    @media (max-width:900px){.app{flex-direction:column;padding:12px}.left{width:100%;position:relative;height:auto}.right{height:auto}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left">
      <div class="d-flex align-items-start mb-3">
        <div>
          <h4 class="mb-0">18.2 Network APIs</h4>
          <div class="muted">Fetch, XHR, WebSocket, SSE, Request Interceptors — JavaScript</div>
          <div class="mt-2"><small class="muted">Author: Advanced JS Tutor • Updated: Nov 28, 2025</small></div>
        </div>
      </div>

      <div class="toc-search">
        <input id="tocSearch" class="form-control form-control-sm" placeholder="Search TOC..." aria-label="Search table of contents"/>
        <button id="tocClear" class="btn btn-sm btn-outline-secondary">Clear</button>
      </div>

      <div class="controls">
        <button id="expandAll" class="btn btn-sm btn-primary">Expand all</button>
        <button id="collapseAll" class="btn btn-sm btn-ghost">Collapse all</button>
        <button id="tocCollapse" class="btn btn-sm btn-ghost">Collapse TOC</button>
      </div>

      <nav>
        <ul id="tocList" class="toc-list">
          <li class="toc-item" data-target="intro">Introduction &amp; Exec Summary</li>
          <li class="toc-item" data-target="fetch">Fetch API &amp; Modern HTTP</li>
          <li class="toc-item" data-target="xhr">XMLHttpRequest (Legacy)</li>
          <li class="toc-item" data-target="ws">WebSocket — Real-time</li>
          <li class="toc-item" data-target="sse">Server-Sent Events (SSE)</li>
          <li class="toc-item" data-target="interceptors">Request Interceptors &amp; Middleware</li>
          <li class="toc-item" data-target="patterns">Patterns &amp; Error Handling</li>
          <li class="toc-item" data-target="examples">Examples &amp; Cheatsheet</li>
        </ul>
      </nav>
    </aside>

    <main class="right" id="content">
      <section id="intro" class="section">
        <h2>Introduction &amp; Executive Summary <span class="pill">Quick</span></h2>
        <details open>
          <summary><div class="summary-title"><strong>Executive summary</strong><span class="muted">(short)</span></div></summary>
          <div class="mt-2 muted">This module dives into browser network APIs: modern <code>fetch()</code> for promises-based HTTP, legacy <code>XMLHttpRequest</code>, bi-directional <code>WebSocket</code>, one-way streaming via <code>EventSource</code> (SSE), and how to implement request interceptors and middleware patterns (e.g., in fetch wrappers or libraries) to handle auth, retries, and logging.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Why this matters</strong></div></summary>
          <div class="mt-2">Network is the lifeblood of web apps. Choosing the right API and layering robust retry, timeout, and error-handling strategies prevents subtle bugs, improves UX, and reduces wasted bandwidth. We'll explain mechanisms and when to prefer each API.</div>
        </details>
      </section>

      <section id="fetch" class="section">
        <h3>Fetch API &amp; Modern HTTP Requests</h3>
        <details>
          <summary><div class="summary-title"><strong>Overview</strong></div></summary>
          <div class="mt-2"><code>fetch</code> is promise-based, supports streaming responses, request/response cloning, and is more flexible than XHR. It integrates with Service Workers, CORS, and works well with async/await.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Basic usage</strong></div></summary>
          <div class="mt-2">
            <pre><code>&lt;!-- fetch-basic.js --&gt;
// GET
const res = await fetch('/api/items');
if(!res.ok) throw new Error('Network response was not ok');
const data = await res.json();

// POST with JSON
const postRes = await fetch('/api/items', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ name: 'item' })
});
</code></pre>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Timeouts &amp; AbortController</strong></div></summary>
          <div class="mt-2">Use <code>AbortController</code> to cancel long-running requests (e.g., when component unmounts or user navigates away).</div>
          <pre><code>// fetch with timeout
const controller = new AbortController();
const timeout = setTimeout(() =&gt; controller.abort(), 5000);
try{
  const res = await fetch('/api/slow', { signal: controller.signal });
  const json = await res.json();
}catch(err){
  if(err.name === 'AbortError') console.warn('request aborted');
}
clearTimeout(timeout);
</code></pre>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Streaming responses</strong></div></summary>
          <div class="mt-2">Fetch supports reading the response body as a stream via <code>res.body.getReader()</code>, useful for large downloads or progressive JSON parsing.</div>
          <pre><code>// read stream example (simplified)
const res = await fetch('/big-data');
const reader = res.body.getReader();
let received = '';
while(true){
  const { done, value } = await reader.read();
  if(done) break;
  received += new TextDecoder().decode(value);
}
</code></pre>
        </details>
      </section>

      <section id="xhr" class="section">
        <h3>XMLHttpRequest (Legacy)</h3>
        <details>
          <summary><div class="summary-title"><strong>Why it still matters</strong></div></summary>
          <div class="mt-2">XHR is older, callback-based, but still used in legacy systems. It's synchronous option (deprecated in main thread) and still has use in some environments. Understand it to read old codebases and for fallback scenarios.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Example</strong></div></summary>
          <div class="mt-2">
            <pre><code>// XHR GET example
const xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data');
xhr.onreadystatechange = function(){
  if(xhr.readyState === 4){
    if(xhr.status >= 200 &amp;&amp; xhr.status &lt; 300){
      console.log('response', JSON.parse(xhr.responseText));
    } else {
      console.error('xhr error', xhr.status);
    }
  }
};
xhr.send();
</code></pre>
          </div>
        </details>
      </section>

      <section id="ws" class="section">
        <h3>WebSocket — Real-time Bi-directional Communication</h3>
        <details>
          <summary><div class="summary-title"><strong>Overview</strong></div></summary>
          <div class="mt-2">WebSocket provides a persistent, low-latency, bi-directional TCP-like connection between client and server. Use it for chat, live updates, games, and collaborative apps. Compared to polling or SSE, WebSocket supports client-to-server messages easily.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Basic client example</strong></div></summary>
          <div class="mt-2">
            <pre><code>// WebSocket client
const ws = new WebSocket('wss://example.com/socket');
ws.addEventListener('open', () =&gt; console.log('connected'));
ws.addEventListener('message', (ev) =&gt; console.log('message', ev.data));
ws.addEventListener('close', () =&gt; console.log('closed'));
ws.addEventListener('error', (e) =&gt; console.error('ws error', e));

// send a message
ws.send(JSON.stringify({ type: 'ping' }));
</code></pre>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Reconnection &amp; heartbeat</strong></div></summary>
          <div class="mt-2">Implement exponential backoff for reconnection and periodic pings to detect dead peers. Avoid tight reconnect loops.</div>
          <pre><code>// naive reconnect example
let socket;
let attempts = 0;
function connect(){
  socket = new WebSocket('wss://example.com/socket');
  socket.onopen = () =&gt; { attempts = 0; };
  socket.onclose = () =&gt; { setTimeout(connect, Math.min(30000, 1000 * Math.pow(2, attempts++))); };
}
connect();
</code></pre>
        </details>
      </section>

      <section id="sse" class="section">
        <h3>Server-Sent Events (SSE)</h3>
        <details>
          <summary><div class="summary-title"><strong>Overview</strong></div></summary>
          <div class="mt-2">SSE (EventSource) is a lightweight way for servers to push text/event-stream updates to the client. It's uni-directional (server → client) and simpler than WebSocket for many realtime use-cases like notifications or live feeds.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Client example</strong></div></summary>
          <div class="mt-2">
            <pre><code>// SSE client
const es = new EventSource('/events');
es.addEventListener('message', (ev) =&gt; {
  console.log('event', ev.data);
});
es.addEventListener('error', (e) =&gt; console.error('sse error', e));
</code></pre>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Server (pseudo) format</strong></div></summary>
          <div class="mt-2">
            <pre><code>// response is text/event-stream with lines like:
// data: {"foo":"bar"}\n\n
// Example (Node/Express):
res.setHeader('Content-Type', 'text/event-stream');
res.write('data: ' + JSON.stringify({ time: Date.now() }) + '\n\n');
</code></pre>
          </div>
        </details>
      </section>

      <section id="interceptors" class="section">
        <h3>Request Interceptors &amp; Middleware</h3>
        <details>
          <summary><div class="summary-title"><strong>Concept</strong></div></summary>
          <div class="mt-2">Interceptors wrap requests/responses to inject behavior: auth headers, retries, logging, error normalization, circuit breakers, etc. You can implement them as small middleware stacks around fetch or use libraries (Axios) that provide built-in interceptors.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Simple fetch wrapper with middleware</strong></div></summary>
          <div class="mt-2">Small composable middleware stack for fetch.</div>
          <pre><code>// fetch-middleware.js
function createClient(){
  const middlewares = [];
  const use = (mw) =&gt; { middlewares.push(mw); };

  const client = async (input, init = {}) =&gt; {
    let ctx = { request: new Request(input, init) };
    // run request middlewares
    for(const mw of middlewares){
      if(mw.onRequest) await mw.onRequest(ctx);
    }
    ctx.response = await fetch(ctx.request);
    // run response middlewares
    for(const mw of middlewares){
      if(mw.onResponse) await mw.onResponse(ctx);
    }
    return ctx.response;
  };

  return { use, client };
}

// usage
const api = createClient();
api.use({
  onRequest: async (ctx) =&gt; { const token = await getAuthToken(); ctx.request = new Request(ctx.request, { headers: { ...Object.fromEntries(ctx.request.headers), Authorization: `Bearer ${token}` } }); }
});

const res = await api.client('/api/data');
</code></pre>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Retries &amp; idempotency</strong></div></summary>
          <div class="mt-2">Retry only idempotent methods (GET, HEAD, PUT if safe), use exponential backoff and jitter. For POST, prefer server-assigned idempotency keys.</div>
        </details>
      </section>

      <section id="patterns" class="section">
        <h3>Patterns &amp; Error Handling</h3>
        <details>
          <summary><div class="summary-title"><strong>Timeouts, retries, circuit breaker</strong></div></summary>
          <div class="mt-2">Combine AbortController for timeouts with retry logic and circuit-breaker patterns to avoid overwhelming the server and improve UX during outages.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Caching &amp; stale-while-revalidate</strong></div></summary>
          <div class="mt-2">Use Cache-Control headers, Service Workers and Cache API for offline or stale-while-revalidate strategies. Client-side in-memory caches (LRU) help reduce repeated network calls.</div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Security considerations</strong></div></summary>
          <div class="mt-2">Avoid leaking secrets in URLs. Use HTTPS, validate TLS, properly configure CORS, and protect against SSRF on server endpoints used by clients.</div>
        </details>
      </section>

      <section id="examples" class="section">
        <h3>Examples &amp; Cheatsheet</h3>
        <details>
          <summary><div class="summary-title"><strong>Example: fetch wrapper with retries &amp; timeout</strong></div></summary>
          <div class="mt-2">
            <pre><code>// retry-fetch.js (compact)
async function fetchWithRetry(url, opts = {}, retries = 3, timeout = 5000){
  for(let attempt=0; attempt&lt;=retries; attempt++){
    const controller = new AbortController();
    const id = setTimeout(() =&gt; controller.abort(), timeout);
    try{
      const res = await fetch(url, { ...opts, signal: controller.signal });
      clearTimeout(id);
      if(!res.ok && attempt &lt; retries) { await new Promise(r =&gt; setTimeout(r, 100 * Math.pow(2, attempt))); continue; }
      return res;
    }catch(err){
      clearTimeout(id);
      if(err.name === 'AbortError' &amp;&amp; attempt &lt; retries) continue; // retry
      throw err;
    }
  }
}
</code></pre>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Example: SSE vs WebSocket decision guide</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li>Use <strong>SSE</strong> for simple server → client event streams with auto-reconnect and text-based events.</li>
              <li>Use <strong>WebSocket</strong> for full duplex communication, binary messages, and low-latency apps.</li>
            </ul>
          </div>
        </details>

        <details>
          <summary><div class="summary-title"><strong>Cheat sheet</strong></div></summary>
          <div class="mt-2">
            <ul>
              <li><code>fetch()</code> — async/await friendly, streaming, use AbortController for cancelation.</li>
              <li><code>XMLHttpRequest</code> — legacy; understand for reading older code.</li>
              <li><code>WebSocket</code> — persistent bi-directional socket (wss://).</li>
              <li><code>EventSource</code> — server-sent text stream (SSE).</li>
              <li>Interceptors — wrap fetch to add auth, logging, retries, circuit breaking.</li>
            </ul>
          </div>
        </details>
      </section>

      <footer class="mt-4 muted"><small>Designed for students from college to PhD. Want framework-specific adapters (Axios, Angular HttpClient), or sample server code (Node, Go), I can add them. — Advanced JS Tutor</small></footer>
    </main>
  </div>

  <script>
    // TOC interactions, search, expand/collapse, smooth scroll, basic syntax highlight
    document.querySelectorAll('.toc-item').forEach(item =&gt; {
      item.addEventListener('click', () =&gt; {
        const target = document.getElementById(item.dataset.target);
        if(target){
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
          document.querySelectorAll('.section').forEach(s =&gt; s.classList.remove('highlight'));
          target.classList.add('highlight');
          setTimeout(() =&gt; target.classList.remove('highlight'), 1400);
        }
      });
    });

    const tocSearch = document.getElementById('tocSearch');
    const tocList = document.getElementById('tocList');
    tocSearch.addEventListener('input', (e) =&gt; {
      const q = e.target.value.trim().toLowerCase();
      Array.from(tocList.children).forEach(li =&gt; {
        const text = li.textContent.trim().toLowerCase();
        li.style.display = text.includes(q) ? '' : 'none';
      });
    });
    document.getElementById('tocClear').addEventListener('click', () =&gt; { tocSearch.value=''; tocSearch.dispatchEvent(new Event('input')); });

    function setAll(open){ document.querySelectorAll('main details').forEach(d =&gt; { d.open = open; }); }
    document.getElementById('expandAll').addEventListener('click', () =&gt; setAll(true));
    document.getElementById('collapseAll').addEventListener('click', () =&gt; setAll(false));

    document.getElementById('tocCollapse').addEventListener('click', () =&gt; {
      const left = document.querySelector('.left');
      if(left.style.width === '64px'){ left.style.width = getComputedStyle(document.documentElement).getPropertyValue('--panel-width'); }
      else { left.style.width = '64px'; }
    });

    // syntax highlight: simple token coloring (numbers, keywords, JSON keys)
    (function tinyHighlight(){
      const codeBlocks = document.querySelectorAll('pre code');
      const numRE = /\b(\d+)\b/g;
      const kwRE = /\b(const|let|var|function|async|await|return|if|else|for|while|try|catch|new|class)\b/g;
      const jsonKeyRE = /("[\w$]+")\s*:/g;
      codeBlocks.forEach(cb =&gt; {
        let html = cb.innerHTML;
        html = html.replace(jsonKeyRE, '<span style="color:var(--cyan)">$1</span>:');
        html = html.replace(numRE, '<span style="color:var(--cyan)">$1</span>');
        html = html.replace(kwRE, '<span style="color:var(--amber)">$1</span>');
        cb.innerHTML = html;
      });
    })();
  </script>
</body>
</html>
