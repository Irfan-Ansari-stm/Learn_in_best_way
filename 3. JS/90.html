<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>26.1 Client-Side State Management — Deep Learning Note</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">

  <style>
    :root{
      --bg:#0b0f11;
      --surface:#121416;
      --accent-cyan:#06b6d4;
      --accent-amber:#f59e0b;
      --muted:#9aa6a6;
      --panel-width:340px;
      --radius:14px;
    }
    html,body{height:100%;background:var(--bg);color:#e6f3f3;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;margin:0}
    .app{display:grid;grid-template-columns:var(--panel-width) 1fr;gap:18px;padding:20px;height:100vh;box-sizing:border-box}
    .left-panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:var(--radius);padding:18px;position:relative;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    .right-panel{background:var(--surface);border-radius:var(--radius);padding:28px;overflow:auto;height:calc(100vh - 40px);box-shadow: 0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03)}
    .left-fixed{position:sticky;top:20px}
    .title{font-size:18px;font-weight:700;color:white}
    .subtitle{color:var(--muted);font-size:13px;margin-top:6px}
    .meta{margin-top:12px;font-size:13px}
    .toc-search{display:flex;gap:8px;margin-top:12px}
    .toc-list{margin-top:12px}
    .toc-item{padding:8px;border-radius:10px;margin-bottom:6px}
    .toc-item:hover{background:rgba(255,255,255,0.02)}
    .controls{display:flex;gap:8px;margin-top:12px}
    h1,h2,h3{color:#fff}
    h1{font-size:24px} h2{font-size:20px} h3{font-size:16px}
    p{line-height:1.6;color:#dbeaea}
    details{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);padding:12px;border-radius:10px;margin-bottom:12px;border:1px solid rgba(255,255,255,0.02)}
    summary{cursor:pointer;font-weight:600}
    pre{background:rgba(0,0,0,0.6);padding:12px;border-radius:10px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;font-size:13px}
    .section{scroll-margin-top:48px}
    .muted{color:var(--muted)}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg, rgba(6,182,212,0.08), rgba(245,158,11,0.06));font-size:13px}
    @media (max-width:900px){.app{grid-template-columns:1fr}.left-panel{order:2}.right-panel{order:1;height:auto}}
  </style>
</head>
<body>
  <div class="app container-fluid">
    <aside class="left-panel left-fixed" aria-labelledby="toc-title">
      <div class="title">26.1 Client-Side State Management</div>
      <div class="subtitle">Local state, lifting, normalization & immutable updates (JS)</div>
      <div class="meta">
        <div><span class="pill">Author:</span> Deep Tutor</div>
        <div class="muted" style="margin-top:6px">Designed for college → PhD level: deep and details details details</div>
      </div>

      <div class="toc-search">
        <input id="tocFilter" class="form-control form-control-sm" placeholder="Search TOC, e.g. normalization" aria-label="search toc">
        <button id="expandAllBtn" class="btn btn-sm btn-outline-light" title="Expand all TOC">Expand</button>
      </div>

      <div class="controls">
        <button id="collapseAllBtn" class="btn btn-sm btn-outline-light">Collapse</button>
        <button id="topBtn" class="btn btn-sm btn-outline-light" onclick="document.querySelector('.right-panel').scrollTo({top:0, behavior:'smooth'})">Top</button>
      </div>

      <nav class="toc-list" id="tocList">
        <details class="toc-item open"><summary>Overview & Executive Summary</summary>
          <ul>
            <li><a href="#overview">What is Client-side State?</a></li>
            <li><a href="#local">Local Component State</a></li>
            <li><a href="#lifting">Lifting State Up</a></li>
            <li><a href="#normalization">State Normalization</a></li>
            <li><a href="#immutable">Immutable Update Patterns</a></li>
            <li><a href="#examples">Examples & Snippets</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Sections</summary>
          <ul>
            <li><a href="#local">Local component state</a></li>
            <li><a href="#lifting">Lifting state up patterns</a></li>
            <li><a href="#normalization">State normalization strategies</a></li>
            <li><a href="#immutable">Immutable update patterns</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Examples & Code Snippets</summary>
          <ul>
            <li><a href="#example-vanilla">Vanilla JS example</a></li>
            <li><a href="#example-react">React: local & lifting</a></li>
            <li><a href="#example-normalize">Normalization example</a></li>
            <li><a href="#example-immutable">Immutable updates</a></li>
          </ul>
        </details>

        <details class="toc-item"><summary>Further Reading</summary>
          <ul>
            <li><a href="#further">Notes & Links</a></li>
          </ul>
        </details>
      </nav>

      <div style="position:absolute;left:18px;bottom:18px;font-size:12px;color:var(--muted)">Tip: use search to filter headings</div>
    </aside>

    <main class="right-panel" role="main">
      <article>
        <header class="section" id="overview">
          <h1>26.1 Client-Side State Management — Deep Note</h1>
          <p class="muted">This note explains how to design and manage client-side state using layered <code>&lt;details&gt;</code> sections: executive summary, deep dive, syntax/pseudocode, readable examples, and real-world best practices. Examples primarily use plain JavaScript and React-style JS to keep concepts framework-agnostic but practical.</p>
        </header>

        <section class="section" id="local">
          <h2>Local Component State</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Local state is data owned and managed by a single UI component. It is the simplest, fastest place to keep ephemeral values such as form inputs, toggle flags, or UI-only counters. Keep state local until multiple components need it.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Local state reduces coupling: components encapsulate their own behavior and UI. When state remains local, reasoning, testing, and performance are simpler. However, local state should not duplicate data that is authoritative elsewhere (server cache, global store). Use component lifecycle to initialize and cleanup local state.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>// conceptual API (framework-agnostic)
const component = createComponent({
  state: { count: 0, open: false },
  setState(updater) { /* merges or replaces state */ }
});

// read: state.count
// update: setState(prev =&gt; ({ ...prev, count: prev.count + 1 }))
</code></pre>
          </details>

          <details>
            <summary>Readable example (Vanilla JS)</summary>
            <pre><code>// Simple UI state without framework
const btn = document.querySelector('#inc');
const out = document.querySelector('#count');
let count = 0;
btn.addEventListener('click', () =&gt; {
  count += 1;
  out.textContent = String(count);
});
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Use local state for UI-only concerns: modals, input values, local validation. Avoid duplicating server state; instead derive UI state from props or fetch directly when needed. Local state is not suitable for shared or persistent data.</p>
          </details>
        </section>

        <section class="section" id="lifting">
          <h2>Lifting State Up Patterns</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Lifting state up means moving shared state from child components to their nearest common ancestor so multiple children can access and modify it. This pattern avoids prop drilling and keeps a single source of truth.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>When two or more sibling components need to read or update the same data, hoist the state to their parent and pass down values and callbacks. This maintains unidirectional data flow: parent owns state, children operate via props or callbacks. For deeper trees, use context or a lightweight store to avoid excessive prop chains.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>// Parent holds state
parentState = { items: [] };
function addItem(item) { parentState.items.push(item); render(); }
// pass items and addItem to children
</code></pre>
          </details>

          <details>
            <summary>Readable example (React-style)</summary>
            <pre><code>function Parent(){
  const [text, setText] = useState('');
  const [items, setItems] = useState([]);
  function add(){ setItems(prev =&gt; [...prev, { id: Date.now(), text }]); setText(''); }
  return (
    &lt;div&gt;
      &lt;Input value={text} onChange={setText} onAdd={add} /&gt;
      &lt;List items={items} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
          </details>

          <details>
            <summary>Real use cases & best practices</summary>
            <p>Lift state to the closest common ancestor. Use callbacks to mutate state immutably. If many levels separate consumers, prefer context or a small store (Zustand/Pinia/Redux) to avoid prop drilling. Keep the lifted state minimal—store only what is necessary.</p>
          </details>
        </section>

        <section class="section" id="normalization">
          <h2>State Normalization Strategies</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Normalization flattens nested data into lookup tables (by id) and separate lists of ids. This reduces duplication, simplifies updates, and improves performance when updating or accessing individual entities.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Normalized state stores entities in dictionaries keyed by id and keeps references as arrays of ids. This avoids deep nested updates and ensures a single source of truth per entity. Normalization mirrors relational database patterns and is crucial in complex apps or when using caches like Redux stores or client-side DBs.</p>
          </details>

          <details>
            <summary>Syntax & pseudocode</summary>
            <pre><code>// normalized shape
state = {
  usersById: { 'u1': {id:'u1', name:'A'}, 'u2': {id:'u2', name:'B'} },
  postsById: { 'p1': {id:'p1', author:'u1', text:'...'} },
  postsAllIds: ['p1']
}

// update user name: state.usersById['u1'].name = 'New' (immutably)
</code></pre>
          </details>

          <details>
            <summary>Readable example (Normalize API response)</summary>
            <pre><code>// transform nested API response to normalized state
function normalizePosts(apiPosts){
  const postsById = {};
  const usersById = {};
  const postsAllIds = [];
  for(const p of apiPosts){
    postsById[p.id] = { id: p.id, author: p.author.id, title: p.title };
    usersById[p.author.id] = p.author; // last-write wins
    postsAllIds.push(p.id);
  }
  return { postsById, usersById, postsAllIds };
}
</code></pre>
          </details>

          <details>
            <summary>Real use cases & caveats</summary>
            <p>Normalize when entities are shared across features (users, posts, tags). For tiny apps, normalization may be unnecessary overhead. Use libraries (normalizr, @reduxjs/toolkit's createEntityAdapter) to simplify canonical operations: add, update, remove, and selectors.</p>
          </details>
        </section>

        <section class="section" id="immutable">
          <h2>Immutable Update Patterns</h2>

          <details open>
            <summary>Executive summary</summary>
            <p>Immutable updates create new objects/arrays instead of mutating existing ones. This enables simple change detection (shallow equality), time-travel debugging, and avoids accidental shared-state bugs.</p>
          </details>

          <details>
            <summary>Deep explanation</summary>
            <p>Immutable patterns rely on copying the path to the changed value (structural sharing). For nested updates, shallow copies at each level are made. Libraries like Immer simplify immutable updates by providing a mutable-looking API that produces immutable results efficiently.</p>
          </details>

          <details>
            <summary>Syntax & patterns</summary>
            <pre><code>// update array item immutably
const newItems = items.map(it =&gt; it.id === id ? { ...it, done: !it.done } : it);

// update nested object immutably
const newState = {
  ...state,
  entities: {
    ...state.entities,
    [id]: { ...state.entities[id], name: 'New' }
  }
};

// using Immer (mutative style but immutable result)
import produce from 'immer';
const next = produce(state, draft =&gt; { draft.entities[id].name = 'New'; });
</code></pre>
          </details>

          <details>
            <summary>Readable example (React setState with immutable updates)</summary>
            <pre><code>function toggleTodo(id){
  setTodos(prev =&gt; prev.map(t =&gt; t.id === id ? { ...t, done: !t.done } : t));
}

// replace item by id
setItems(prev =&gt; prev.map(i =&gt; i.id === updated.id ? updated : i));
</code></pre>
          </details>

          <details>
            <summary>Real use cases & best practices</summary>
            <p>Prefer immutable updates to enable shallow equality checks (fast shouldComponentUpdate / React.memo). Use helper functions and adapters (createEntityAdapter) to standardize updates. For performance-critical sections with massive lists, consider structural sharing libraries or immutable-js, and measure before optimizing prematurely.</p>
          </details>
        </section>

        <section class="section" id="examples">
          <h2>Examples & Code Snippets</h2>

          <details open>
            <summary>Vanilla JS: simple state object with listeners</summary>
            <pre><code>// Tiny observable store
function createStore(initial){
  let state = initial;
  const listeners = new Set();
  return {
    get() { return state; },
    set(updater){ state = typeof updater === 'function' ? updater(state) : updater; listeners.forEach(l =&gt; l()); },
    subscribe(fn){ listeners.add(fn); return () =&gt; listeners.delete(fn); }
  };
}

const store = createStore({ count: 0 });
store.subscribe(() =&gt; console.log('state changed', store.get()));
store.set(s =&gt; ({ ...s, count: s.count + 1 }));
</code></pre>
          </details>

          <details>
            <summary>React: lift state example (readable)</summary>
            <pre><code>function App(){
  const [items, setItems] = useState([]);
  function add(text){ setItems(prev =&gt; [...prev, { id: Date.now(), text }]); }
  return (&lt;div&gt; &lt;AddItem onAdd={add} /&gt; &lt;ItemList items={items} /&gt; &lt;/div&gt;);
}

function AddItem({onAdd}){
  const [v, setV] = useState('');
  return (&lt;form onSubmit={e =&gt; { e.preventDefault(); onAdd(v); setV(''); }}&gt; ... &lt;/form&gt;);
}
</code></pre>
          </details>

          <details>
            <summary>Normalization: update entity example</summary>
            <pre><code>// normalized state update: update user name
function updateUser(state, user){
  return {
    ...state,
    usersById: { ...state.usersById, [user.id]: { ...state.usersById[user.id], ...user } }
  };
}
</code></pre>
          </details>

          <details>
            <summary>Immutable deep update helper (utility)</summary>
            <pre><code>function setIn(obj, path, value){
  if(path.length === 0) return value;
  const [head, ...rest] = path;
  return { ...obj, [head]: setIn(obj[head] ?? {}, rest, value) };
}

// usage: setIn(state, ['entities','user','u1','name'], 'New')
</code></pre>
          </details>
        </section>

        <section class="section" id="further">
          <h2>Further Reading & Resources</h2>
          <ul>
            <li>Redux docs: normalization + immutable patterns.</li>
            <li>Immer: ergonomic immutable updates.</li>
            <li>Articles: "Lifting state up" (React docs), "Normalized state for client apps".</li>
          </ul>
        </section>

        <footer style="margin-top:24px;color:var(--muted)">
          <small>Generated learning note — client-side state management, single-file HTML. Ask to convert examples to a different framework (Vue/Angular), add TypeScript types, or include advanced patterns (caching, optimistic updates, conflict resolution).</small>
        </footer>
      </article>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded',() =&gt; {
      document.querySelectorAll('pre code').forEach((el) =&gt; { try{ hljs.highlightElement(el); }catch(e){} });
      const filter = document.getElementById('tocFilter');
      filter.addEventListener('input', (e) =&gt; {
        const q = e.target.value.toLowerCase();
        document.querySelectorAll('#tocList details').forEach(d =&gt; { const text = d.textContent.toLowerCase(); d.style.display = text.includes(q) ? '' : 'none'; });
      });
      document.getElementById('expandAllBtn').addEventListener('click', () =&gt; { document.querySelectorAll('#tocList details').forEach(d =&gt; d.open = true); });
      document.getElementById('collapseAllBtn').addEventListener('click', () =&gt; { document.querySelectorAll('#tocList details').forEach(d =&gt; d.open = false); });
      document.querySelectorAll('a[href^="#"]').forEach(a =&gt; { a.addEventListener('click', (e) =&gt; { const href = a.getAttribute('href'); const target = document.querySelector(href); if(target){ e.preventDefault(); document.querySelector('.right-panel').scrollTo({top: target.offsetTop - 12, behavior:'smooth'}); } }); });
      const rp = document.querySelector('.right-panel'); rp.tabIndex = 0;
      const obs = new MutationObserver(() =&gt; { document.querySelectorAll('pre code').forEach((el) =&gt; { try { hljs.highlightElement(el); } catch(e){} }); });
      obs.observe(document.body, {childList:true, subtree:true});
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>