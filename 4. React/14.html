
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 10: Advanced Component Patterns</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-dark: #0a192f;
            --cyan: #00f5ff;
            --amber: #ffb74d;
            --text-light: #e6f1ff;
            --border-color: #00c4ff;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-light);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }

        .sidebar {
            background-color: #0d2140;
            border-right: 2px solid var(--border-color);
            height: 100vh;
            position: fixed;
            overflow-y: auto;
            padding: 1rem;
            width: 280px;
            box-shadow: 5px 0 15px rgba(0, 212, 255, 0.1);
        }

        .content {
            margin-left: 280px;
            padding: 2rem;
            max-height: 100vh;
            overflow-y: auto;
        }

        h1, h2, h3, h4, h5, h6 {
            color: var(--cyan);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3rem;
            margin-top: 2rem;
        }

        h1 {
            font-size: 2.2rem;
            color: var(--amber);
            border-bottom: 3px solid var(--amber);
        }

        .toc-item {
            margin: 0.5rem 0;
            padding: 0.4rem;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: pointer;
            color: var(--text-light);
        }

        .toc-item:hover {
            background-color: rgba(0, 245, 255, 0.1);
            padding-left: 0.8rem;
        }

        .toc-item.active {
            background-color: rgba(0, 245, 255, 0.2);
            border-left: 3px solid var(--cyan);
        }

        .toc-subitem {
            margin-left: 1.5rem;
            font-size: 0.9rem;
            color: #b8c4d6;
            padding: 0.2rem 0;
        }

        .toc-subitem:hover {
            background-color: rgba(0, 245, 255, 0.08);
            padding-left: 0.5rem;
        }

        .search-box {
            margin: 1rem 0;
            background-color: #1a2a40;
            border: 1px solid var(--border-color);
            color: var(--text-light);
        }

        .code-block {
            background-color: #121e33;
            border-left: 4px solid var(--amber);
            border-radius: 6px;
            padding: 1rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            box-shadow: 0 4px 8px rgba(0, 212, 255, 0.1);
        }

        pre code {
            color: var(--cyan);
            display: block;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .highlight {
            background-color: rgba(255, 183, 77, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-weight: 500;
        }

        .note {
            background-color: rgba(0, 245, 255, 0.1);
            border-left: 4px solid var(--cyan);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }

        .warning {
            background-color: rgba(255, 183, 77, 0.15);
            border-left: 4px solid var(--amber);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }

        details {
            margin: 1.5rem 0;
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            background-color: #0d1b33;
        }

        summary {
            padding: 1rem;
            background-color: #122647;
            cursor: pointer;
            font-weight: bold;
            color: var(--cyan);
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        summary:hover {
            background-color: #1a3155;
        }

        summary::before {
            content: "▶ ";
            font-size: 0.9rem;
            transition: transform 0.3s ease;
        }

        details[open] > summary::before {
            content: "▼ ";
            transform: rotate(90deg);
        }

        .btn-control {
            margin-bottom: 1rem;
            background-color: rgba(0, 245, 255, 0.15);
            border: 1px solid var(--border-color);
            color: var(--cyan);
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .btn-control:hover {
            background-color: rgba(0, 245, 255, 0.3);
            transform: translateY(-2px);
        }

        .author-info {
            color: #b8c4d6;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }

        .section-marker {
            color: var(--amber);
            font-weight: bold;
            margin-right: 0.5rem;
        }

        .jsx-tag {
            color: var(--amber);
        }

        .jsx-attr {
            color: #a0eaff;
        }

        .jsx-value {
            color: #a8f5ff;
        }

        .keyword {
            color: #ff9e6d;
        }

        .comment {
            color: #5a7e9d;
            font-style: italic;
        }

        .pattern-name {
            color: var(--amber);
            font-weight: 600;
        }

        /* Responsive adjustments */
        @media (max-width: 991px) {
            .sidebar {
                width: 250px;
            }
            .content {
                margin-left: 250px;
                padding: 1rem;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                position: relative;
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 2px solid var(--border-color);
            }
            .content {
                margin-left: 0;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Left Sidebar -->
    <div class="sidebar">
        <h3 class="text-center mb-4">Chapter 10: Advanced Component Patterns</h3>
        <p class="author-info">Mastered by React Tutor • For Deep Understanding</p>

        <div class="mb-4">
            <input type="text" class="form-control search-box" id="searchToc" placeholder="Search topics...">
        </div>

        <div class="mb-3">
            <button class="btn btn-sm btn-control w-100" id="expandAll">Expand All</button>
            <button class="btn btn-sm btn-control w-100 mt-2" id="collapseAll">Collapse All</button>
        </div>

        <div class="toc">
            <div class="toc-item" data-target="section-10-1">10.1 Higher-Order Components (HOCs)</div>
            <div class="toc-item" data-target="section-10-2">10.2 Render Props Pattern</div>
            <div class="toc-item" data-target="section-10-3">10.3 Compound Components</div>
            <div class="toc-item" data-target="section-10-4">10.4 Controlled Components Pattern</div>
            <div class="toc-item" data-target="section-10-5">10.5 State Reducer Pattern</div>
            <div class="toc-item" data-target="section-10-6">10.6 Provider Pattern</div>
            <div class="toc-item" data-target="section-10-7">10.7 Component Composition Strategies</div>
        </div>
    </div>

    <!-- Right Content Panel -->
    <div class="content">
        <div id="section-10-1">
            <h2><span class="section-marker">10.1</span> Higher-Order Components (HOCs)</h2>
            <details>
                <summary>What Are HOCs?</summary>
                <p>A Higher-Order Component (HOC) is a pattern in React for reusing component logic. It's a function that takes a component and returns a new component with enhanced functionality.</p>
                
                <div class="note">
                    <strong>Core Analogy:</strong> Think of HOCs as decorators or wrappers. Just like you might add a frame to a painting, a HOC adds functionality to a component without modifying its original code.
                </div>
            </details>

            <details>
                <summary>Basic HOC Structure</summary>
                <p>The simplest HOC takes a component and returns a new component.</p>
                
                <div class="code-block">
                    <code>
{`// Basic HOC structure
function withLogging(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log('Component rendered:', WrappedComponent.name);
    
    return &lt;WrappedComponent {...props} /&gt;;
  };
}

// Usage
const MyComponent = ({ name }) =&gt; &lt;div&gt;Hello, {name}&lt;/div&gt;;

const EnhancedMyComponent = withLogging(MyComponent);

// Now use EnhancedMyComponent instead of MyComponent
&lt;EnhancedMyComponent name="Alice" /&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Practical Example: Authentication HOC</summary>
                <p>Let's create a HOC that restricts access to components based on authentication status.</p>
                
                <div class="code-block">
                    <code>
{`import { useContext } from 'react';
import { AuthContext } from './AuthContext';

// HOC that requires authentication
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const { user, loading } = useContext(AuthContext);
    
    if (loading) {
      return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    if (!user) {
      return &lt;div&gt;You must be logged in to view this page.&lt;/div&gt;;
    }
    
    return &lt;WrappedComponent {...props} /&gt;;
  };
}

// Original component
function Dashboard({ user }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;
      &lt;!-- Dashboard content --&gt;
    &lt;/div&gt;
  );
}

// Enhanced component using HOC
const AuthenticatedDashboard = withAuth(Dashboard);

// Usage
&lt;AuthenticatedDashboard /&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Advanced HOC: Data Fetching</summary>
                <p>HOCs can handle complex data fetching logic.</p>
                
                <div class="code-block">
                    <code>
{`import { useState, useEffect } from 'react';

// HOC that fetches data and provides it as props
function withData(WrappedComponent, fetchDataFunction) {
  return function DataComponent(props) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() =&gt; {
      fetchDataFunction()
        .then(result =&gt; {
          setData(result);
          setLoading(false);
        })
        .catch(err =&gt; {
          setError(err.message);
          setLoading(false);
        });
    }, []); // Run once on mount
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    
    // Pass the data as props to the wrapped component
    return &lt;WrappedComponent data={data} {...props} /&gt;;
  };
}

// Original component
function UserList({ users }) {
  return (
    &lt;ul&gt;
      {users.map(user =&gt; (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Enhanced component
const DataLoadedUserList = withData(UserList, () =&gt; 
  fetch('/api/users').then(r =&gt; r.json())
);

// Usage
&lt;DataLoadedUserList /&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Multiple HOCs Chaining</summary>
                <p>You can combine multiple HOCs together.</p>
                
                <div class="code-block">
                    <code>
{`// Original component
function Profile({ user, isAdmin, isLoading }) {
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      {isAdmin &amp;&amp; &lt;button&gt;Admin Controls&lt;/button&gt;}
    &lt;/div&gt;
  );
}

// HOCs
const AuthenticatedProfile = withAuth(Profile);
const WithUserData = withData(AuthenticatedProfile, () =&gt; fetch('/api/user').then(r =&gt; r.json()));
const WithAdminCheck = withAdmin(WithUserData);

// Final component
const EnhancedProfile = WithAdminCheck;

// Usage
&lt;EnhancedProfile /&gt;`}
                    </code>
                </div>
                
                <div class="warning">
                    <strong>Problem:</strong> This creates deeply nested components that are hard to debug and understand.
                </div>
            </details>

            <details>
                <summary>HOCs vs Custom Hooks</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>HOCs</th>
                            <th>Custom Hooks</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Structure</strong></td>
                            <td>Wraps components in additional components</td>
                            <td>Functions that use hooks</td>
                        </tr>
                        <tr>
                            <td><strong>API</strong></td>
                            <td>Props injection</td>
                            <td>Return values</td>
                        </tr>
                        <tr>
                            <td><strong>Nesting</strong></td>
                            <td>Can create deep nesting</td>
                            <td>No nesting - flat structure</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Creates additional component layers</td>
                            <td>Minimal overhead</td>
                        </tr>
                        <tr>
                            <td><strong>Debugging</strong></td>
                            <td>Harder - component tree gets complex</td>
                            <td>Easier - normal React dev tools</td>
                        </tr>
                        <tr>
                            <td><strong>Flexibility</strong></td>
                            <td>Less flexible - tied to component structure</td>
                            <td>More flexible - can be used anywhere</td>
                        </tr>
                        <tr>
                            <td><strong>Modern Recommendation</strong></td>
                            <td>Deprecated for most use cases</td>
                            <td>Recommended approach</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="note">
                    <strong>Important:</strong> While HOCs were popular in earlier React versions, custom hooks have largely replaced them for most use cases. HOCs are now mainly seen in legacy code or specific advanced scenarios.
                </div>
            </details>

            <details>
                <summary>When to Use HOCs Today</summary>
                <p>HOCs still have some valid use cases:</p>
                
                <ul>
                    <li><strong>Legacy codebases:</strong> When maintaining older React applications</li>
                    <li><strong>Third-party libraries:</strong> Some libraries still provide HOCs</li>
                    <li><strong>Non-React-specific logic:</strong> When you need to wrap non-component logic</li>
                    <li><strong>Complex wrapping with multiple concerns:</strong> When multiple HOCs are needed for different concerns</li>
                </ul>
                
                <div class="warning">
                    <strong>Modern Alternative:</strong> For most cases, use custom hooks instead:
                    <pre><code>// Instead of HOC
const EnhancedComponent = withAuth(Component);

// Use custom hook
function MyComponent() {
  const { user, loading, error } = useAuth();
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  if (!user) return &lt;div&gt;Login required&lt;/div&gt;;
  
  return &lt;Component /&gt;;
}</code></pre>
                </div>
            </details>
        </div>

        <div id="section-10-2">
            <h2><span class="section-marker">10.2</span> Render Props Pattern</h2>
            <details>
                <summary>What Are Render Props?</summary>
                <p>The render props pattern is a technique for sharing code between React components using a prop whose value is a function that returns JSX.</p>
                
                <div class="note">
                    <strong>Core Concept:</strong> "Render what you're given." The component doesn't decide what to render—it receives a function that tells it what to render.
                </div>
            </details>

            <details>
                <summary>Basic Render Prop Structure</summary>
                <p>A component accepts a render function as a prop and calls it to determine what to render.</p>
                
                <div class="code-block">
                    <code>
{`// Render Prop Component
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) =&gt; {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    &lt;div style={{ height: '100vh' }} onMouseMove={handleMouseMove}&gt;
      {render(position)}
    &lt;/div&gt;
  );
}

// Usage - Passing render function
function App() {
  return (
    &lt;MouseTracker 
      render={({ x, y }) =&gt; (
        &lt;h1&gt;The mouse position is ({x}, {y})&lt;/h1&gt;
      )}
    /&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Real-World Example: Data Fetching with Render Props</summary>
                <p>Let's create a reusable data fetching component using render props.</p>
                
                <div class="code-block">
                    <code>
{`import { useState, useEffect } from 'react';

function DataFetcher({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() =&gt; {
    fetch(url)
      .then(response =&gt; {
        if (!response.ok) throw new Error(\`HTTP error! status: \${response.status}\`);
        return response.json();
      })
      .then(result =&gt; {
        setData(result);
        setLoading(false);
      })
      .catch(err =&gt; {
        setError(err.message);
        setLoading(false);
      });
  }, [url]);
  
  // Render prop pattern
  return children({ data, loading, error });
}

// Usage
function UserProfile({ userId }) {
  return (
    &lt;DataFetcher url={`/api/users/\${userId}`}&gt;
      {({ data, loading, error }) =&gt; {
        if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
        if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
        
        return (
          &lt;div&gt;
            &lt;h1&gt;{data.name}&lt;/h1&gt;
            &lt;p&gt;Email: {data.email}&lt;/p&gt;
            &lt;p&gt;Bio: {data.bio}&lt;/p&gt;
          &lt;/div&gt;
        );
      }}
    &lt;/DataFetcher&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Render Props vs Children as Function</summary>
                <p>The render props pattern often uses the special <code>children</code> prop.</p>
                
                <div class="code-block">
                    <code>
{`// Same functionality - just different API
function DataFetcher({ url, children }) {
  // ... same implementation ...
  
  return children({ data, loading, error });
}

// Usage with children prop
function UserProfile({ userId }) {
  return (
    &lt;DataFetcher url={`/api/users/\${userId}`} &gt;
      {({ data, loading, error }) =&gt; {
        if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
        if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
        
        return (
          &lt;div&gt;
            &lt;h1&gt;{data.name}&lt;/h1&gt;
            &lt;p&gt;Email: {data.email}&lt;/p&gt;
            &lt;p&gt;Bio: {data.bio}&lt;/p&gt;
          &lt;/div&gt;
        );
      }}
    &lt;/DataFetcher&gt;
  );
}}

// You can also pass other props
function MouseTracker({ children }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) =&gt; {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    &lt;div style={{ height: '100vh' }} onMouseMove={handleMouseMove}&gt;
      {children({
        x: position.x,
        y: position.y,
        move: handleMouseMove
      })}
    &lt;/div&gt;
  );
}

// Usage
function App() {
  return (
    &lt;MouseTracker&gt;
      {({ x, y, move }) =&gt; (
        &lt;div&gt;
          &lt;h1&gt;Mouse at ({x}, {y})&lt;/h1&gt;
          &lt;button onClick={move}&gt;Trigger Move&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/MouseTracker&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Render Props vs Custom Hooks</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Render Props</th>
                            <th>Custom Hooks</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Structure</strong></td>
                            <td>Component with render prop</td>
                            <td>Function returning state and functions</td>
                        </tr>
                        <tr>
                            <td><strong>Reusability</strong></td>
                            <td>Reusable across components</td>
                            <td>Reusable across components</td>
                        </tr>
                        <tr>
                            <td><strong>API Complexity</strong></td>
                            <td>Higher - requires component wrapper</td>
                            <td>Lower - simple function call</td>
                        </tr>
                        <tr>
                            <td><strong>Code Readability</strong></td>
                            <td>Can be verbose</td>
                            <td>More concise</td>
                        </tr>
                        <tr>
                            <td><strong>Testing</strong></td>
                            <td>Requires testing component</td>
                            <td>Direct function testing</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Creates additional component layer</td>
                            <td>Minimal overhead</td>
                        </tr>
                        <tr>
                            <td><strong>Modern Recommendation</strong></td>
                            <td>Largely superseded by hooks</td>
                            <td>Preferred modern approach</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="note">
                    <strong>Pro Tip:</strong> Render props are still useful when you need to share not just state but also DOM-related behavior (like mouse tracking) that requires actual DOM elements.
                </div>
            </details>

            <details>
                <summary>Render Props with Multiple Values</summary>
                <p>Render props can return complex objects with multiple values and functions.</p>
                
                <div class="code-block">
                    <code>
{`// Advanced render prop component
function FormHandler({ initialValues, onSubmit, children }) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (e) =&gt; {
    const { name, value } = e.target;
    setValues(prev =&gt; ({ ...prev, [name]: value }));
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev =&gt; ({ ...prev, [name]: '' }));
    }
  };
  
  const handleSubmit = async (e) =&gt; {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      await onSubmit(values);
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return children({
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit
  });
}

// Usage
function LoginForm() {
  return (
    &lt;FormHandler 
      initialValues={{ email: '', password: '' }}
      onSubmit={async (values) =&gt; {
        // Submit to API
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(values)
        });
        
        if (!response.ok) {
          throw new Error('Login failed');
        }
        
        return response.json();
      }}
    &gt;
      {({
        values,
        errors,
        isSubmitting,
        handleChange,
        handleSubmit
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;input 
            name="email"
            value={values.email}
            onChange={handleChange}
            placeholder="Email"
          /&gt;
          {errors.email &amp;&amp; &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
          
          &lt;input 
            name="password"
            type="password"
            value={values.password}
            onChange={handleChange}
            placeholder="Password"
          /&gt;
          {errors.password &amp;&amp; &lt;span className="error"&gt;{errors.password}&lt;/span&gt;}
          
          {errors.submit &amp;&amp; &lt;div className="error"&gt;{errors.submit}&lt;/div&gt;}
          
          &lt;button type="submit" disabled={isSubmitting}&gt;
            {isSubmitting ? 'Logging in...' : 'Login'}
          &lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/FormHandler&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>When to Use Render Props Today</summary>
                <p>Render props are still valuable in these scenarios:</p>
                
                <ul>
                    <li><strong>DOM manipulation:</strong> When you need to expose DOM-related behavior (mouse, keyboard events)</li>
                    <li><strong>Complex layout components:</strong> When you want to control rendering structure</li>
                    <li><strong>Library development:</strong> When building reusable UI libraries</li>
                    <li><strong>Conditional rendering patterns:</strong> When you need fine-grained control over what gets rendered</li>
                </ul>
                
                <div class="warning">
                    <strong>Modern Alternative:</strong> For most state management needs, use custom hooks instead:
                    <pre><code>// Instead of render props
&lt;DataFetcher url="/api/data"&gt;
  {({ data, loading, error }) =&gt; ...}
&lt;/DataFetcher&gt;

// Use custom hook
function MyComponent() {
  const { data, loading, error } = useApi('/api/data');
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return &lt;div&gt;{JSON.stringify(data)}&lt;/div&gt;;
}</code></pre>
                </div>
            </details>
        </div>

        <div id="section-10-3">
            <h2><span class="section-marker">10.3</span> Compound Components</h2>
            <details>
                <summary>What Are Compound Components?</summary>
                <p>Compound components are a pattern where multiple components work together as a single unit, often sharing state internally through React context or parent-child relationships.</p>
                
                <div class="note">
                    <strong>Core Insight:</strong> The parent component manages state and passes down behavior to child components, which don't know about each other but work together seamlessly.
                </div>
            </details>

            <details>
                <summary>Basic Compound Component Structure</summary>
                <p>Components are designed to be used together and rely on their relationship.</p>
                
                <div class="code-block">
                    <code>
{`// Tab system
function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);
  
  const tabs = React.Children.toArray(children).filter(
    child =&gt; child.type === Tab
  );
  
  return (
    &lt;div&gt;
      &lt;div className="tabs-header"&gt;
        {tabs.map((tab, index) =&gt; (
          &lt;button 
            key={index} 
            onClick={() =&gt; setActiveTab(index)}
            className={index === activeTab ? 'active' : ''}
          &gt;
            {tab.props.label}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;
      &lt;div className="tabs-content"&gt;
        {tabs[activeTab]}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function Tab({ label, children }) {
  return &lt;div&gt;{children}&lt;/div&gt;;
}

// Usage
&lt;Tabs&gt;
  &lt;Tab label="Profile"&gt;
    &lt;UserProfile /&gt;
  &lt;/Tab&gt;
  &lt;Tab label="Settings"&gt;
    &lt;SettingsPanel /&gt;
  &lt;/Tab&gt;
&lt;/Tabs&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Advanced Example: Accordion</summary>
                <p>Let's build a more sophisticated compound component system.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function Accordion({ children }) {
  const [openIndexes, setOpenIndexes] = useState([]);
  
  const toggleSection = (index) =&gt; {
    setOpenIndexes(prev =&gt; {
      if (prev.includes(index)) {
        return prev.filter(i =&gt; i !== index);
      } else {
        return [...prev, index];
      }
    });
  };
  
  return (
    &lt;div className="accordion"&gt;
      {React.Children.map(children, (child, index) =&gt;
        React.cloneElement(child, {
          isOpen: openIndexes.includes(index),
          onToggle: () =&gt; toggleSection(index),
          index
        })
      )}
    &lt;/div&gt;
  );
}

function AccordionItem({ title, children, isOpen, onToggle }) {
  return (
    &lt;div className="accordion-item"&gt;
      &lt;button 
        className="accordion-header" 
        onClick={onToggle}
      &gt;
        {title}
        &lt;span&gt;{isOpen ? '−' : '+'}&lt;/span&gt;
      &lt;/button&gt;
      {isOpen &amp;&amp; (
        &lt;div className="accordion-content"&gt;
          {children}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

// Usage
&lt;Accordion&gt;
  &lt;AccordionItem title="Section 1"&gt;
    &lt;p&gt;Content for section 1&lt;/p&gt;
  &lt;/AccordionItem&gt;
  &lt;AccordionItem title="Section 2"&gt;
    &lt;p&gt;Content for section 2&lt;/p&gt;
  &lt;/AccordionItem&gt;
  &lt;AccordionItem title="Section 3"&gt;
    &lt;p&gt;Content for section 3&lt;/p&gt;
  &lt;/AccordionItem&gt;
&lt;/Accordion&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Compound Components with Context</summary>
                <p>Use context to share state between compound components.</p>
                
                <div class="code-block">
                    <code>
{`import { createContext, useContext } from 'react';

// Create context
const TabsContext = createContext();

function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);
  
  const value = {
    activeTab,
    setActiveTab
  };
  
  return (
    &lt;TabsContext.Provider value={value}&gt;
      {children}
    &lt;/TabsContext.Provider&gt;
  );
}

function TabList({ children }) {
  const { activeTab } = useContext(TabsContext);
  
  return (
    &lt;div className="tab-list"&gt;
      {React.Children.map(children, (child, index) =&gt;
        React.cloneElement(child, {
          isActive: index === activeTab,
          index
        })
      )}
    &lt;/div&gt;
  );
}

function Tab({ children, isActive, index }) {
  const { setActiveTab } = useContext(TabsContext);
  
  return (
    &lt;button 
      onClick={() =&gt; setActiveTab(index)}
      className={isActive ? 'active' : ''}
    &gt;
      {children}
    &lt;/button&gt;
  );
}

function TabPanel({ children }) {
  const { activeTab } = useContext(TabsContext);
  const tabChildren = React.Children.toArray(children);
  
  return (
    &lt;div className="tab-panel"&gt;
      {tabChildren[activeTab]}
    &lt;/div&gt;
  );
}

// Usage
&lt;Tabs&gt;
  &lt;TabList&gt;
    &lt;Tab&gt;Profile&lt;/Tab&gt;
    &lt;Tab&gt;Settings&lt;/Tab&gt;
    &lt;Tab&gt;Notifications&lt;/Tab&gt;
  &lt;/TabList&gt;
  &lt;TabPanel&gt;
    &lt;UserProfile /&gt;
    &lt;SettingsPanel /&gt;
    &lt;NotificationPanel /&gt;
  &lt;/TabPanel&gt;
&lt;/Tabs&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Compound Components vs Render Props</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Compound Components</th>
                            <th>Render Props</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Usage Pattern</strong></td>
                            <td>Components used together in a specific hierarchy</td>
                            <td>Single component with render function prop</td>
                        </tr>
                        <tr>
                            <td><strong>State Management</strong></td>
                            <td>Shared via context or parent</td>
                            <td>Passed as arguments to render function</td>
                        </tr>
                        <tr>
                            <td><strong>API Design</strong></td>
                            <td>Declarative, HTML-like</td>
                            <td>Functional, callback-based</td>
                        </tr>
                        <tr>
                            <td><strong>Learning Curve</strong></td>
                            <td>Higher - understanding component relationships</td>
                            <td>Medium - understanding render functions</td>
                        </tr>
                        <tr>
                            <td><strong>Readability</strong></td>
                            <td>High - looks like regular JSX</td>
                            <td>Medium - can get complex with nested functions</td>
                        </tr>
                        <tr>
                            <td><strong>Flexibility</strong></td>
                            <td>Lower - rigid structure</td>
                            <td>Higher - full control over rendering</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>UI components with fixed structure</td>
                            <td>Behavioral components with flexible output</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="note">
                    <strong>Key Advantage:</strong> Compound components feel natural and familiar because they look like regular HTML/XML markup. Users don't need to learn a new API—they just use components together.
                </div>
            </details>

            <details>
                <summary>Compound Components with Validation</summary>
                <p>Let's build a form validation system using compound components.</p>
                
                <div class="code-block">
                    <code>
{`import { useState, createContext, useContext } from 'react';

const FormContext = createContext();

function Form({ children, onSubmit }) {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (e) =&gt; {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      await onSubmit(values);
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const updateValue = (name, value) =&gt; {
    setValues(prev =&gt; ({ ...prev, [name]: value }));
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev =&gt; ({ ...prev, [name]: '' }));
    }
  };
  
  const validateField = (name, validator) =&gt; {
    const error = validator(values[name]);
    setErrors(prev =&gt; ({ ...prev, [name]: error }));
  };
  
  const value = {
    values,
    errors,
    isSubmitting,
    updateValue,
    validateField,
    handleSubmit
  };
  
  return (
    &lt;FormContext.Provider value={value}&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        {children}
      &lt;/form&gt;
    &lt;/FormContext.Provider&gt;
  );
}

function Input({ name, label, type = 'text', validators = [], ...props }) {
  const { values, errors, updateValue, validateField } = useContext(FormContext);
  
  const handleChange = (e) =&gt; {
    updateValue(name, e.target.value);
    validators.forEach(validator =&gt; validateField(name, validator));
  };
  
  return (
    &lt;div className="form-group"&gt;
      &lt;label htmlFor={name}&gt;{label}&lt;/label&gt;
      &lt;input 
        id={name}
        name={name}
        type={type}
        value={values[name] || ''}
        onChange={handleChange}
        {...props}
      /&gt;
      {errors[name] &amp;&amp; &lt;span className="error"&gt;{errors[name]}&lt;/span&gt;}
    &lt;/div&gt;
  );
}

function SubmitButton({ children = 'Submit' }) {
  const { isSubmitting } = useContext(FormContext);
  
  return (
    &lt;button type="submit" disabled={isSubmitting}&gt;
      {isSubmitting ? 'Processing...' : children}
    &lt;/button&gt;
  );
}

// Usage
&lt;Form onSubmit={async (values) =&gt; {
  // Submit to API
  const response = await fetch('/api/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(values)
  });
  
  if (!response.ok) {
    throw new Error('Registration failed');
  }
}}&gt;
  &lt;Input 
    name="username" 
    label="Username" 
    validators={[
      (value) =&gt; !value ? 'Username is required' : '',
      (value) =&gt; value.length &lt; 3 ? 'Username must be at least 3 characters' : ''
    ]}
  /&gt;
  
  &lt;Input 
    name="email" 
    label="Email" 
    type="email"
    validators={[
      (value) =&gt; !value ? 'Email is required' : '',
      (value) =&gt; !/\S+@\S+\.\S+/.test(value) ? 'Invalid email format' : ''
    ]}
  /&gt;
  
  &lt;Input 
    name="password" 
    label="Password" 
    type="password"
    validators={[
      (value) =&gt; !value ? 'Password is required' : '',
      (value) =&gt; value.length &lt; 8 ? 'Password must be at least 8 characters' : ''
    ]}
  /&gt;
  
  &lt;SubmitButton /&gt;
&lt;/Form&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Compound Component Best Practices</summary>
                <ol>
                    <li><strong>Use descriptive names:</strong> Make it clear how components work together</li>
                    <li><strong>Document relationships:</strong> Clearly document which components should be used together</li>
                    <li><strong>Provide fallbacks:</strong> Handle cases where components are used incorrectly</li>
                    <li><strong>Use PropTypes or TypeScript:</strong> Enforce correct usage</li>
                    <li><strong>Keep it simple:</strong> Don't overcomplicate the API</li>
                    <li><strong>Test thoroughly:</strong> Test the entire component group together</li>
                </ol>
                
                <div class="warning">
                    <strong>Common Pitfall:</strong> Avoid making compound components too tightly coupled. They should still be somewhat independent and testable.
                </div>
            </details>
        </div>

        <div id="section-10-4">
            <h2><span class="section-marker">10.4</span> Controlled Components Pattern</h2>
            <details>
                <summary>What Are Controlled Components?</summary>
                <p>Controlled components are form elements whose value is controlled by React state rather than the DOM itself. This gives React complete control over the form's state.</p>
                
                <div class="note">
                    <strong>Core Concept:</strong> In controlled components, React is the source of truth for form values. The DOM element's value is always determined by React state.
                </div>
            </details>

            <details>
                <summary>Basic Controlled Component</summary>
                <p>Every form input has its value managed by React state.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function ControlledForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    message: ''
  });
  
  const handleChange = (event) =&gt; {
    const { name, value } = event.target;
    setFormData(prev =&gt; ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    console.log('Form submitted:', formData);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input 
          type="text" 
          id="username" 
          name="username" 
          value={formData.username} 
          onChange={handleChange} 
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input 
          type="email" 
          id="email" 
          name="email" 
          value={formData.email} 
          onChange={handleChange} 
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="message"&gt;Message:&lt;/label&gt;
        &lt;textarea 
          id="message" 
          name="message" 
          value={formData.message} 
          onChange={handleChange} 
        &gt;&lt;/textarea&gt;
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Controlled vs Uncontrolled Components</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Controlled Components</th>
                            <th>Uncontrolled Components</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Data Source</strong></td>
                            <td>React state</td>
                            <td>DOM</td>
                        </tr>
                        <tr>
                            <td><strong>Value Attribute</strong></td>
                            <td>Always present</td>
                            <td>Optional (<code>defaultValue</code>)</td>
                        </tr>
                        <tr>
                            <td><strong>Update Mechanism</strong></td>
                            <td>onChange handler updates state</td>
                            <td>Refs read current value</td>
                        </tr>
                        <tr>
                            <td><strong>Validation</strong></td>
                            <td>Easier - happens in state update</td>
                            <td>Harder - requires DOM inspection</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Slightly slower due to re-renders</td>
                            <td>Faster for simple cases</td>
                        </tr>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>Higher - more boilerplate</td>
                            <td>Lower - less code</td>
                        </tr>
                        <tr>
                            <td><strong>Recommended</strong></td>
                            <td><strong>YES</strong> - React's preferred approach</td>
                            <td>Only for edge cases</td>
                        </tr>
                    </tbody>
                </table>
            </details>

            <details>
                <summary>Controlled Components with Complex Logic</summary>
                <p>Controlled components excel at handling complex form logic.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function AdvancedForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    newsletter: false,
    bio: ''
  });
  
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (event) =&gt; {
    const { name, value, type, checked } = event.target;
    const inputValue = type === 'checkbox' ? checked : value;
    
    setFormData(prev =&gt; ({
      ...prev,
      [name]: inputValue
    }));
    
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev =&gt; ({ ...prev, [name]: '' }));
    }
  };
  
  const validateForm = () =&gt; {
    const newErrors = {};
    
    // Username validation
    if (!formData.firstName.trim()) {
      newErrors.firstName = 'First name is required';
    }
    
    if (!formData.lastName.trim()) {
      newErrors.lastName = 'Last name is required';
    }
    
    // Email validation
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    // Phone validation
    if (formData.phone &amp;&amp; !/^\\+?[1-9]\\d{1,14}$/.test(formData.phone)) {
      newErrors.phone = 'Phone number is invalid';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (event) =&gt; {
    event.preventDefault();
    
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    
    try {
      // Simulate API call
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));
      console.log('Form submitted:', formData);
      // Reset form after successful submission
      setFormData({
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        newsletter: false,
        bio: ''
      });
    } catch (error) {
      setErrors({ submit: 'Submission failed. Please try again.' });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="firstName"&gt;First Name:&lt;/label&gt;
        &lt;input 
          type="text" 
          id="firstName" 
          name="firstName" 
          value={formData.firstName} 
          onChange={handleChange} 
          className={errors.firstName ? 'error' : ''}
        /&gt;
        {errors.firstName &amp;&amp; &lt;span className="error-message"&gt;{errors.firstName}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="lastName"&gt;Last Name:&lt;/label&gt;
        &lt;input 
          type="text" 
          id="lastName" 
          name="lastName" 
          value={formData.lastName} 
          onChange={handleChange} 
          className={errors.lastName ? 'error' : ''}
        /&gt;
        {errors.lastName &amp;&amp; &lt;span className="error-message"&gt;{errors.lastName}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input 
          type="email" 
          id="email" 
          name="email" 
          value={formData.email} 
          onChange={handleChange} 
          className={errors.email ? 'error' : ''}
        /&gt;
        {errors.email &amp;&amp; &lt;span className="error-message"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="phone"&gt;Phone:&lt;/label&gt;
        &lt;input 
          type="tel" 
          id="phone" 
          name="phone" 
          value={formData.phone} 
          onChange={handleChange} 
          className={errors.phone ? 'error' : ''}
        /&gt;
        {errors.phone &amp;&amp; &lt;span className="error-message"&gt;{errors.phone}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;
          &lt;input 
            type="checkbox" 
            name="newsletter" 
            checked={formData.newsletter} 
            onChange={handleChange} 
          /&gt;
          Subscribe to newsletter
        &lt;/label&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="bio"&gt;Bio:&lt;/label&gt;
        &lt;textarea 
          id="bio" 
          name="bio" 
          value={formData.bio} 
          onChange={handleChange} 
        &gt;&lt;/textarea&gt;
      &lt;/div&gt;
      
      {errors.submit &amp;&amp; &lt;div className="error-message"&gt;{errors.submit}&lt;/div&gt;}
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Submitting...' : 'Submit'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Controlled Components with Dynamic Fields</summary>
                <p>Handle forms with dynamic fields using controlled components.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function DynamicForm() {
  const [formData, setFormData] = useState({
    name: '',
    skills: ['']
  });
  
  const handleChange = (event) =&gt; {
    const { name, value } = event.target;
    setFormData(prev =&gt; ({
      ...prev,
      [name]: value
    }));
  };
  
  const handleSkillChange = (index, value) =&gt; {
    setFormData(prev =&gt; ({
      ...prev,
      skills: prev.skills.map((skill, i) =&gt; 
        i === index ? value : skill
      )
    }));
  };
  
  const addSkill = () =&gt; {
    setFormData(prev =&gt; ({
      ...prev,
      skills: [...prev.skills, '']
    }));
  };
  
  const removeSkill = (index) =&gt; {
    setFormData(prev =&gt; ({
      ...prev,
      skills: prev.skills.filter((_, i) =&gt; i !== index)
    }));
  };
  
  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;
        &lt;input 
          type="text" 
          id="name" 
          name="name" 
          value={formData.name} 
          onChange={handleChange} 
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Skills:&lt;/label&gt;
        {formData.skills.map((skill, index) =&gt; (
          &lt;div key={index} style={{ marginBottom: '0.5rem' }}&gt;
            &lt;input 
              type="text" 
              value={skill} 
              onChange={(e) =&gt; handleSkillChange(index, e.target.value)} 
              placeholder="Enter skill"
            /&gt;
            &lt;button 
              type="button" 
              onClick={() =&gt; removeSkill(index)}
              style={{ marginLeft: '0.5rem' }}
            &gt;
              Remove
            &lt;/button&gt;
          &lt;/div&gt;
        ))}
        &lt;button type="button" onClick={addSkill}&gt;Add Skill&lt;/button&gt;
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Controlled Components with External Libraries</summary>
                <p>Even when using third-party libraries, controlled components remain the best practice.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';

function ControlledDatePicker() {
  const [selectedDate, setSelectedDate] = useState(null);
  
  return (
    &lt;div&gt;
      &lt;label&gt;Select Date:&lt;/label&gt;
      &lt;DatePicker 
        selected={selectedDate}  // Controlled prop
        onChange={(date) =&gt; setSelectedDate(date)}  // Update state
        dateFormat="MM/dd/yyyy"
      /&gt;
    &lt;/div&gt;
  );
}

// Another example with a rich text editor
import { useState } from 'react';
import RichTextEditor from 'react-rte';

function ControlledRichText() {
  const [value, setValue] = useState(RichTextEditor.createEmptyValue());
  
  const handleChange = (newValue) =&gt; {
    setValue(newValue);
  };
  
  return (
    &lt;div&gt;
      &lt;RichTextEditor 
        value={value}  // Controlled prop
        onChange={handleChange}  // Update state
      /&gt;
      &lt;div&gt;HTML: {value.toString('html')}&lt;/div&gt;
    &lt;/div&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Why Controlled Components Are Preferred</summary>
                <ol>
                    <li><strong>Full Control:</strong> React has complete control over form state</li>
                    <li><strong>Immediate Validation:</strong> Can validate and provide feedback instantly</li>
                    <li><strong>Consistent Behavior:</strong> Works the same across all browsers</li>
                    <li><strong>Easy Testing:</strong> Easy to simulate user input in tests</li>
                    <li><strong>Integration with State:</strong> Seamlessly integrates with other React state</li>
                    <li><strong>Dynamic Updates:</strong> Easy to programmatically update form values</li>
                </ol>
                
                <div class="note">
                    <strong>Real-world Analogy:</strong> Think of controlled components as a puppet master controlling a puppet. The puppet master (React) controls every movement of the puppet (form input), ensuring precise control over its state and behavior.
                </div>
            </details>
        </div>

        <div id="section-10-5">
            <h2><span class="section-marker">10.5</span> State Reducer Pattern</h2>
            <details>
                <summary>What Is the State Reducer Pattern?</summary>
                <p>The state reducer pattern allows consumers of a component to customize how state changes are processed before they're applied. It separates the state logic from the component's internal implementation.</p>
                
                <div class="note">
                    <strong>Core Concept:</strong> Instead of forcing state changes, the component asks: "How would you like me to change the state?" This gives consumers maximum flexibility.
                </div>
            </details>

            <details>
                <summary>Basic State Reducer Pattern</summary>
                <p>Accept a reducer function as a prop that determines how state changes.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function Counter({ 
  initialCount = 0, 
  step = 1, 
  reducer = (state, action) =&gt; {
    switch (action.type) {
      case 'increment':
        return state + action.step;
      case 'decrement':
        return state - action.step;
      default:
        return state;
    }
  }
}) {
  const [count, setCount] = useState(initialCount);
  
  const increment = () =&gt; {
    setCount(prev =&gt; reducer(prev, {
      type: 'increment',
      step
    }));
  };
  
  const decrement = () =&gt; {
    setCount(prev =&gt; reducer(prev, {
      type: 'decrement',
      step
    }));
  };
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+{step}&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-{step}&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Usage with custom reducer
function App() {
  return (
    &lt;Counter 
      initialCount={10} 
      step={5}
      reducer={(state, action) =&gt; {
        // Custom logic: only allow even numbers
        if (action.type === 'increment') {
          return state + action.step;
        }
        if (action.type === 'decrement') {
          return state - action.step;
        }
        return state;
      }}
    /&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Advanced Example: Toggle Component</summary>
                <p>Let's build a flexible toggle component using the state reducer pattern.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function Toggle({ 
  initialState = false, 
  reducer = (state, action) =&gt; {
    switch (action.type) {
      case 'toggle':
        return !state;
      case 'set':
        return action.value;
      case 'reset':
        return initialState;
      default:
        return state;
    }
  }
}) {
  const [on, setOn] = useState(initialState);
  
  const toggle = () =&gt; {
    setOn(prev =&gt; reducer(prev, { type: 'toggle' }));
  };
  
  const setOnValue = (value) =&gt; {
    setOn(prev =&gt; reducer(prev, { type: 'set', value }));
  };
  
  const reset = () =&gt; {
    setOn(prev =&gt; reducer(prev, { type: 'reset' }));
  };
  
  return {
    on,
    toggle,
    setOn: setOnValue,
    reset
  };
}

// Usage with custom reducer
function App() {
  const { on, toggle, setOn } = Toggle({
    initialState: false,
    reducer: (state, action) =&gt; {
      // Custom logic: prevent turning off during work hours (9am-5pm)
      if (action.type === 'toggle' &amp;&amp; !state) {
        const hour = new Date().getHours();
        if (hour &gt;= 9 &amp;&amp; hour &lt; 17) {
          console.log('Cannot turn on during work hours!');
          return state; // Prevent toggle
        }
      }
      
      // Default behavior for other actions
      switch (action.type) {
        case 'toggle':
          return !state;
        case 'set':
          return action.value;
        default:
          return state;
      }
    }
  });
  
  return (
    &lt;div&gt;
      &lt;button onClick={toggle}&gt;Toggle: {on ? 'ON' : 'OFF'}&lt;/button&gt;
      &lt;button onClick={() =&gt; setOn(true)}&gt;Force ON&lt;/button&gt;
    &lt;/div&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>State Reducer Pattern with Compound Components</summary>
                <p>Combine state reducer with compound components for maximum flexibility.</p>
                
                <div class="code-block">
                    <code>
{`import { useState, createContext, useContext } from 'react';

const ToggleContext = createContext();

function Toggle({ 
  initialState = false, 
  reducer = (state, action) =&gt; {
    switch (action.type) {
      case 'toggle':
        return !state;
      case 'set':
        return action.value;
      default:
        return state;
    }
  },
  children
}) {
  const [on, setOn] = useState(initialState);
  
  const toggle = () =&gt; {
    setOn(prev =&gt; reducer(prev, { type: 'toggle' }));
  };
  
  const setOnValue = (value) =&gt; {
    setOn(prev =&gt; reducer(prev, { type: 'set', value }));
  };
  
  const value = {
    on,
    toggle,
    setOn: setOnValue
  };
  
  return (
    &lt;ToggleContext.Provider value={value}&gt;
      {children}
    &lt;/ToggleContext.Provider&gt;
  );
}

function ToggleButton({ children }) {
  const { on, toggle } = useContext(ToggleContext);
  
  return (
    &lt;button onClick={toggle}&gt;
      {children || (on ? 'ON' : 'OFF')}
    &lt;/button&gt;
  );
}

function ToggleIndicator({ children }) {
  const { on } = useContext(ToggleContext);
  
  return (
    &lt;span&gt;
      {children ? children(on) : on ? 'ON' : 'OFF'}
    &lt;/span&gt;
  );
}

// Usage with custom reducer
function App() {
  return (
    &lt;Toggle 
      initialState={false}
      reducer={(state, action) =&gt; {
        // Custom logic: require confirmation for turning off
        if (action.type === 'toggle' &amp;&amp; state) {
          const confirmed = window.confirm('Are you sure you want to turn this off?');
          if (!confirmed) {
            return state; // Prevent toggle
          }
        }
        
        // Default behavior
        switch (action.type) {
          case 'toggle':
            return !state;
          case 'set':
            return action.value;
          default:
            return state;
        }
      }}
    &gt;
      &lt;ToggleButton&gt;Toggle Me&lt;/ToggleButton&gt;
      &lt;ToggleIndicator&gt;{(on) =&gt; `Current state: ${on ? 'Active' : 'Inactive'}`} &lt;/ToggleIndicator&gt;
    &lt;/Toggle&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>State Reducer Pattern with Form Validation</summary>
                <p>Apply the state reducer pattern to form validation.</p>
                
                <div class="code-block">
                    <code>
{`import { useState } from 'react';

function useForm({ 
  initialValues, 
  reducer = (state, action) =&gt; {
    switch (action.type) {
      case 'update':
        return {
          ...state,
          values: {
            ...state.values,
            [action.field]: action.value
          },
          errors: {
            ...state.errors,
            [action.field]: ''
          }
        };
      case 'setErrors':
        return {
          ...state,
          errors: {
            ...state.errors,
            ...action.errors
          }
        };
      case 'submitStart':
        return { ...state, isSubmitting: true };
      case 'submitSuccess':
        return { ...state, isSubmitting: false, isSubmitted: true };
      case 'submitError':
        return {
          ...state,
          isSubmitting: false,
          errors: {
            ...state.errors,
            submit: action.error
          }
        };
      case 'reset':
        return {
          values: initialValues,
          errors: {},
          isSubmitting: false,
          isSubmitted: false
        };
      default:
        return state;
    }
  }
}) {
  const [state, setState] = useState({
    values: initialValues,
    errors: {},
    isSubmitting: false,
    isSubmitted: false
  });
  
  const updateField = (field, value) =&gt; {
    setState(prev =&gt; reducer(prev, {
      type: 'update',
      field,
      value
    }));
  };
  
  const setErrors = (errors) =&gt; {
    setState(prev =&gt; reducer(prev, {
      type: 'setErrors',
      errors
    }));
  };
  
  const handleSubmit = async (event) =&gt; {
    event.preventDefault();
    
    setState(prev =&gt; reducer(prev, { type: 'submitStart' }));
    
    try {
      // Validate form
      const errors = validateForm(state.values);
      if (Object.keys(errors).length &gt; 0) {
        setErrors(errors);
        return;
      }
      
      // Submit form
      await submitForm(state.values);
      
      setState(prev =&gt; reducer(prev, { type: 'submitSuccess' }));
    } catch (error) {
      setState(prev =&gt; reducer(prev, {
        type: 'submitError',
        error: error.message
      }));
    }
  };
  
  const resetForm = () =&gt; {
    setState(prev =&gt; reducer(prev, { type: 'reset' }));
  };
  
  return {
    values: state.values,
    errors: state.errors,
    isSubmitting: state.isSubmitting,
    isSubmitted: state.isSubmitted,
    updateField,
    handleSubmit,
    resetForm
  };
}

// Usage with custom reducer
function App() {
  const { 
    values, 
    errors, 
    isSubmitting, 
    updateField, 
    handleSubmit 
  } = useForm({
    initialValues: { username: '', email: '' },
    reducer: (state, action) =&gt; {
      // Custom logic: normalize email to lowercase
      if (action.type === 'update' &amp;&amp; action.field === 'email') {
        action.value = action.value.toLowerCase();
      }
      
      // Default behavior
      switch (action.type) {
        case 'update':
          return {
            ...state,
            values: {
              ...state.values,
              [action.field]: action.value
            },
            errors: {
              ...state.errors,
              [action.field]: ''
            }
          };
        case 'setErrors':
          return {
            ...state,
            errors: {
              ...state.errors,
              ...action.errors
            }
          };
        default:
          return state;
      }
    }
  });
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input 
          type="text" 
          id="username" 
          name="username" 
          value={values.username} 
          onChange={(e) =&gt; updateField('username', e.target.value)} 
        /&gt;
        {errors.username &amp;&amp; &lt;span className="error"&gt;{errors.username}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input 
          type="email" 
          id="email" 
          name="email" 
          value={values.email} 
          onChange={(e) =&gt; updateField('email', e.target.value)} 
        /&gt;
        {errors.email &amp;&amp; &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Submitting...' : 'Submit'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Benefits of State Reducer Pattern</summary>
                <ul>
                    <li><strong>Maximum Flexibility:</strong> Consumers can customize state changes</li>
                    <li><strong>Separation of Concerns:</strong> Logic is separated from presentation</li>
                    <li><strong>Testability:</strong> Reducers are pure functions that are easy to test</li>
                    <li><strong>Extensibility:</strong> Easy to add new behaviors without modifying core logic</li>
                    <li><strong>Composability:</strong> Reducers can be combined and reused</li>
                </ul>
            </details>

            <details>
                <summary>When to Use State Reducer Pattern</summary>
                <p>Use this pattern when:</p>
                <ul>
                    <li>You're building a library or component that needs to be highly customizable</li>
                    <li>You anticipate multiple use cases with different state modification requirements</li>
                    <li>You want to make your component's behavior predictable and testable</li>
                    <li>You need to support advanced customization without breaking encapsulation</li>
                </ul>
                
                <div class="warning">
                    <strong>Don't Overuse:</strong> For simple components with straightforward behavior, the state reducer pattern adds unnecessary complexity.
                </div>
            </details>
        </div>

        <div id="section-10-6">
            <h2><span class="section-marker">10.6</span> Provider Pattern</h2>
            <details>
                <summary>What Is the Provider Pattern?</summary>
                <p>The provider pattern is a design pattern where a component (the provider) makes data or functionality available to its descendants through React context, without requiring explicit prop passing.</p>
                
                <div class="note">
                    <strong>Core Concept:</strong> Providers act as centralized sources of truth that feed data down to any component that needs it, regardless of depth in the component tree.
                </div>
            </details>

            <details>
                <summary>Basic Provider Pattern</summary>
                <p>Create a context and a provider component that wraps the application.</p>
                
                <div class="code-block">
                    <code>
{`import { createContext, useContext, useState } from 'react';

// 1. Create context with default value
export const ThemeContext = createContext('light');

// 2. Create provider component
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () =&gt; {
    setTheme(prevTheme =&gt; prevTheme === 'light' ? 'dark' : 'light');
  };
  
  // 3. Provide values to descendants
  const value = {
    theme,
    toggleTheme,
    isDark: theme === 'dark'
  };
  
  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// 4. Create consumer hook
export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// 5. Wrap app with provider
function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;Header /&gt;
      &lt;MainContent /&gt;
      &lt;Footer /&gt;
    &lt;/ThemeProvider&gt;
  );
}

// 6. Consume in any descendant component
function Button() {
  const { theme, toggleTheme, isDark } = useTheme();
  
  return (
    &lt;button 
      onClick={toggleTheme}
      style={{
        backgroundColor: isDark ? '#333' : '#fff',
        color: isDark ? '#fff' : '#333'
      }}
    &gt;
      Toggle {isDark ? 'Light' : 'Dark'} Mode
    &lt;/button&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Multiple Providers for Different Concerns</summary>
                <p>Create separate providers for different types of data.</p>
                
                <div class="code-block">
                    <code>
{`import { createContext, useContext, useState } from 'react';

// Authentication context
export const AuthContext = createContext({
  user: null,
  login: () =&gt; {},
  logout: () =&gt; {}
});

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const login = (userData) =&gt; {
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
  };
  
  const logout = () =&gt; {
    setUser(null);
    localStorage.removeItem('user');
  };
  
  const value = { user, login, logout };
  
  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}

// Language context
export const LanguageContext = createContext({
  language: 'en',
  setLanguage: () =&gt; {}
});

export function LanguageProvider({ children }) {
  const [language, setLanguage] = useState('en');
  
  const value = { language, setLanguage };
  
  return (
    &lt;LanguageContext.Provider value={value}&gt;
      {children}
    &lt;/LanguageContext.Provider&gt;
  );
}

// Theme context
export const ThemeContext = createContext({
  theme: 'light',
  toggleTheme: () =&gt; {}
});

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light');
  };
  
  const value = { theme, toggleTheme, isDark: theme === 'dark' };
  
  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Combine providers
function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;LanguageProvider&gt;
        &lt;ThemeProvider&gt;
          &lt;AppRouter /&gt;
        &lt;/ThemeProvider&gt;
      &lt;/LanguageProvider&gt;
    &lt;/AuthProvider&gt;
  );
}

// Consume anywhere
function Header() {
  const { user, logout } = useAuth();
  const { language, setLanguage } = useLanguage();
  const { theme, toggleTheme } = useTheme();
  
  return (
    &lt;header&gt;
      {user ? (
        &lt;div&gt;
          Welcome, {user.name}!
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;button onClick={() =&gt; navigate('/login')}&gt;Login&lt;/button&gt;
      )}
      
      &lt;select value={language} onChange={(e) =&gt; setLanguage(e.target.value)}&gt;
        &lt;option value="en"&gt;English&lt;/option&gt;
        &lt;option value="es"&gt;Español&lt;/option&gt;
        &lt;option value="fr"&gt;Français&lt;/option&gt;
      &lt;/select&gt;
      
      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;
    &lt;/header&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Provider Pattern with State Management</summary>
                <p>Use the provider pattern to implement global state management.</p>
                
                <div class="code-block">
                    <code>
{`import { createContext, useContext, useReducer } from 'react';

// Action types
const ACTIONS = {
  ADD_ITEM: 'ADD_ITEM',
  REMOVE_ITEM: 'REMOVE_ITEM',
  UPDATE_ITEM: 'UPDATE_ITEM',
  CLEAR_CART: 'CLEAR_CART'
};

// Initial state
const initialState = {
  items: [],
  total: 0
};

// Reducer function
const cartReducer = (state, action) =&gt; {
  switch (action.type) {
    case ACTIONS.ADD_ITEM:
      const existingItem = state.items.find(item =&gt; item.id === action.item.id);
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =&gt; 
            item.id === action.item.id 
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
          total: state.total + action.item.price
        };
      }
      
      return {
        ...state,
        items: [...state.items, { ...action.item, quantity: 1 }],
        total: state.total + action.item.price
      };
      
    case ACTIONS.REMOVE_ITEM:
      const itemToRemove = state.items.find(item =&gt; item.id === action.itemId);
      
      if (!itemToRemove) return state;
      
      const newTotal = state.total - (itemToRemove.price * itemToRemove.quantity);
      
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.itemId),
        total: newTotal
      };
      
    case ACTIONS.UPDATE_ITEM:
      const itemToUpdate = state.items.find(item =&gt; item.id === action.itemId);
      
      if (!itemToUpdate) return state;
      
      const quantityDiff = action.quantity - itemToUpdate.quantity;
      const newTotalForUpdate = state.total + (itemToUpdate.price * quantityDiff);
      
      return {
        ...state,
        items: state.items.map(item =&gt; 
          item.id === action.itemId 
            ? { ...item, quantity: action.quantity }
            : item
        ),
        total: newTotalForUpdate
      };
      
    case ACTIONS.CLEAR_CART:
      return initialState;
      
    default:
      return state;
  }
};

// Context
export const CartContext = createContext({
  state: initialState,
  dispatch: () =&gt; {}
});

// Provider
export function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);
  
  const addToCart = (item) =&gt; {
    dispatch({ type: ACTIONS.ADD_ITEM, item });
  };
  
  const removeFromCart = (itemId) =&gt; {
    dispatch({ type: ACTIONS.REMOVE_ITEM, itemId });
  };
  
  const updateCartItem = (itemId, quantity) =&gt; {
    dispatch({ type: ACTIONS.UPDATE_ITEM, itemId, quantity });
  };
  
  const clearCart = () =&gt; {
    dispatch({ type: ACTIONS.CLEAR_CART });
  };
  
  const value = {
    state,
    dispatch,
    addToCart,
    removeFromCart,
    updateCartItem,
    clearCart
  };
  
  return (
    &lt;CartContext.Provider value={value}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

// Consumer hook
export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}

// Usage
function App() {
  return (
    &lt;CartProvider&gt;
      &lt;Header /&gt;
      &lt;ProductList /&gt;
      &lt;ShoppingCart /&gt;
      &lt;Footer /&gt;
    &lt;/CartProvider&gt;
  );
}

function ProductCard({ product }) {
  const { addToCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;\${product.price}&lt;/p&gt;
      &lt;button onClick={() =&gt; addToCart(product)}&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
  );
}

function ShoppingCart() {
  const { state, removeFromCart, updateCartItem, clearCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Shopping Cart ({state.items.length} items)&lt;/h2&gt;
      &lt;ul&gt;
        {state.items.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - \${item.price} × {item.quantity}
            &lt;button onClick={() =&gt; removeFromCart(item.id)}&gt;Remove&lt;/button&gt;
            &lt;button onClick={() =&gt; updateCartItem(item.id, item.quantity - 1)}&gt;-&lt;/button&gt;
            &lt;button onClick={() =&gt; updateCartItem(item.id, item.quantity + 1)}&gt;+&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total: \${state.total.toFixed(2)}&lt;/p&gt;
      &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;
    &lt;/div&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Provider Pattern with Context and Hooks</summary>
                <p>Combine provider pattern with custom hooks for optimal developer experience.</p>
                
                <div class="code-block">
                    <code>
{`import { createContext, useContext, useState, useCallback } from 'react';

// Create context with default empty object
export const AppContext = createContext({});

// Create provider
export function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [theme, setTheme] = useState('light');
  
  // Memoized functions
  const login = useCallback((userData) =&gt; {
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
  }, []);
  
  const logout = useCallback(() =&gt; {
    setUser(null);
    localStorage.removeItem('user');
  }, []);
  
  const toggleTheme = useCallback(() =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light');
  }, []);
  
  const addNotification = useCallback((notification) =&gt; {
    setNotifications(prev =&gt; [...prev, notification]);
  }, []);
  
  const removeNotification = useCallback((id) =&gt; {
    setNotifications(prev =&gt; prev.filter(n =&gt; n.id !== id));
  }, []);
  
  const value = {
    user,
    notifications,
    theme,
    login,
    logout,
    toggleTheme,
    addNotification,
    removeNotification
  };
  
  return (
    &lt;AppContext.Provider value={value}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Create custom hooks for each concern
export function useUser() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useUser must be used within AppProvider');
  return context.user;
}

export function useNotifications() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useNotifications must be used within AppProvider');
  return {
    notifications: context.notifications,
    add: context.addNotification,
    remove: context.removeNotification
  };
}

export function useTheme() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useTheme must be used within AppProvider');
  return {
    theme: context.theme,
    toggle: context.toggleTheme
  };
}

export function useAuth() {
  const context = useContext(AppContext);
  if (!context) throw new Error('useAuth must be used within AppProvider');
  return {
    user: context.user,
    login: context.login,
    logout: context.logout
  };
}

// Usage
function Header() {
  const user = useUser();
  const { theme, toggle } = useTheme();
  const { notifications, add, remove } = useNotifications();
  
  return (
    &lt;header&gt;
      {user ? (
        &lt;div&gt;
          Welcome, {user.name}!
          &lt;button onClick={user.logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;button onClick={() =&gt; navigate('/login')}&gt;Login&lt;/button&gt;
      )}
      
      &lt;button onClick={toggle}&gt;Toggle Theme&lt;/button&gt;
      
      {notifications.length &gt; 0 &amp;&amp; (
        &lt;div className="notifications"&gt;
          {notifications.map(notification =&gt; (
            &lt;div key={notification.id}&gt;
              {notification.message}
              &lt;button onClick={() =&gt; remove(notification.id)}&gt;×&lt;/button&gt;
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/header&gt;
  );
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Provider Pattern Best Practices</summary>
                <ol>
                    <li><strong>Use meaningful names:</strong> Follow naming conventions like <code>ThemeProvider</code>, <code>AuthContext</code></li>
                    <li><strong>Provide defaults:</strong> Always provide a reasonable default value for context</li>
                    <li><strong>Use custom hooks:</strong> Create hooks like <code>useTheme()</code> for better DX</li>
                    <li><strong>Throw helpful errors:</strong> Check if context is used outside provider</li>
                    <li><strong>Use useCallback:</strong> Memoize functions passed in context to prevent unnecessary re-renders</li>
                    <li><strong>Split concerns:</strong> Create separate providers for different types of data</li>
                    <li><strong>Consider performance:</strong> Only provide what's needed, avoid large objects</li>
                    <li><strong>Document usage:</strong> Clearly document how to use each provider</li>
                </ol>
                
                <div class="note">
                    <strong>Pro Tip:</strong> The provider pattern works beautifully with the state reducer pattern. You can have a provider that manages complex state with a reducer function, giving consumers maximum flexibility while maintaining centralized state management.
                </div>
            </details>

            <details>
                <summary>Provider Pattern vs Redux</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Provider Pattern</th>
                            <th>Redux</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>Low - built into React</td>
                            <td>High - requires additional library</td>
                        </tr>
                        <tr>
                            <td><strong>Bundle Size</strong></td>
                            <td>Zero additional bundle size</td>
                            <td>~2-5kb additional bundle size</td>
                        </tr>
                        <tr>
                            <td><strong>Learning Curve</strong></td>
                            <td>Low - uses familiar React concepts</td>
                            <td>High - requires learning new concepts</td>
                        </tr>
                        <tr>
                            <td><strong>Development Tools</strong></td>
                            <td>Standard React DevTools</td>
                            <td>Redux DevTools extension</td>
                        </tr>
                        <tr>
                            <td><strong>Middleware Support</strong></td>
                            <td>Manual implementation</td>
                            <td>Native support (thunk, saga, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>TypeScript Support</strong></td>
                            <td>Excellent</td>
                            <td>Excellent</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>Small to medium apps, simple state</td>
                            <td>Large apps, complex state, team collaboration</td>
                        </tr>
                        <tr>
                            <td><strong>Recommendation</strong></td>
                            <td><strong>Use for most cases</strong></td>
                            <td>Use for complex enterprise applications</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="warning">
                    <strong>Important:</strong> For most applications, the provider pattern with React context is sufficient and recommended. Reach for Redux only when you have proven performance issues or very complex state management needs.
                </div>
            </details>
        </div>

        <div id="section-10-7">
            <h2><span class="section-marker">10.7</span> Component Composition Strategies</h2>
            <details>
                <summary>Composition vs Inheritance</summary>
                <p>React favors composition over inheritance. Instead of creating hierarchies through inheritance, compose components by combining them.</p>
                
                <div class="note">
                    <strong>Core Philosophy:</strong> "Compose, don't inherit." Build complex UIs by combining simple components rather than extending them.
                </div>
            </details>

            <details>
                <summary>Pattern 1: Layout Components</summary>
                <p>Use composition to create reusable layout structures.</p>
                
                <div class="code-block">
                    <code>
{`// Layout component
function PageLayout({ header, footer, children }) {
  return (
    &lt;div className="page-layout"&gt;
      {header}
      &lt;main&gt;{children}&lt;/main&gt;
      {footer}
    &lt;/div&gt;
  );
}

// Usage
&lt;PageLayout 
  header={&lt;Header /&gt;}
  footer={&lt;Footer /&gt;}
&gt;
  &lt;HomePageContent /&gt;
&lt;/PageLayout&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 2: Wrapper Components</summary>
                <p>Create components that add behavior around other components.</p>
                
                <div class="code-block">
                    <code>
{`// Authenticated wrapper
function Authenticated({ children }) {
  const { user } = useAuth();
  
  if (!user) {
    return &lt;LoginPrompt /&gt;;
  }
  
  return children;
}

// Loading wrapper
function Loading({ isLoading, children, fallback = &lt;div&gt;Loading...&lt;/div&gt; }) {
  if (isLoading) {
    return fallback;
  }
  
  return children;
}

// Error boundary wrapper
function ErrorBoundary({ children, fallback = &lt;div&gt;Something went wrong.&lt;/div&gt; }) {
  const [hasError, setHasError] = useState(false);
  
  useEffect(() =&gt; {
    const handleError = (error) =&gt; {
      setHasError(true);
      console.error('Error caught:', error);
    };
    
    window.addEventListener('error', handleError);
    return () =&gt; window.removeEventListener('error', handleError);
  }, []);
  
  if (hasError) {
    return fallback;
  }
  
  return children;
}

// Usage
&lt;Authenticated&gt;
  &lt;Loading isLoading={loading}&gt;
    &lt;ErrorBoundary&gt;
      &lt;Dashboard /&gt;
    &lt;/ErrorBoundary&gt;
  &lt;/Loading&gt;
&lt;/Authenticated&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 3: Container Components</summary>
                <p>Separate data-fetching logic from presentation logic.</p>
                
                <div class="code-block">
                    <code>
{`// Container component - handles data fetching
function UserContainer({ userId }) {
  const { data: user, loading, error } = useApi(`/api/users/\${userId}`);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return &lt;UserView user={user} /&gt;;
}

// Presentation component - pure UI
function UserView({ user }) {
  return (
    &lt;div className="user-view"&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Bio: {user.bio}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Usage
&lt;UserContainer userId={123} /&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 4: Compound Components</summary>
                <p>Build components that work together as a unit.</p>
                
                <div class="code-block">
                    <code>
{`// Tab system
function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);
  
  const tabs = React.Children.toArray(children).filter(
    child =&gt; child.type === Tab
  );
  
  return (
    &lt;div&gt;
      &lt;div className="tabs-header"&gt;
        {tabs.map((tab, index) =&gt; (
          &lt;button 
            key={index} 
            onClick={() =&gt; setActiveTab(index)}
            className={index === activeTab ? 'active' : ''}
          &gt;
            {tab.props.label}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;
      &lt;div className="tabs-content"&gt;
        {tabs[activeTab]}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function Tab({ label, children }) {
  return &lt;div&gt;{children}&lt;/div&gt;;
}

// Usage
&lt;Tabs&gt;
  &lt;Tab label="Profile"&gt;
    &lt;UserProfile /&gt;
  &lt;/Tab&gt;
  &lt;Tab label="Settings"&gt;
    &lt;SettingsPanel /&gt;
  &lt;/Tab&gt;
&lt;/Tabs&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 5: Render Props</summary>
                <p>Share behavior between components using function props.</p>
                
                <div class="code-block">
                    <code>
{`// Mouse tracker
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  const handleMouseMove = (event) =&gt; {
    setPosition({
      x: event.clientX,
      y: event.clientY
    });
  };
  
  return (
    &lt;div style={{ height: '100vh' }} onMouseMove={handleMouseMove}&gt;
      {render(position)}
    &lt;/div&gt;
  );
}

// Usage
&lt;MouseTracker 
  render={({ x, y }) =&gt; (
    &lt;h1&gt;Mouse position: ({x}, {y})&lt;/h1&gt;
  )}
/&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 6: Higher-Order Components (HOCs)</summary>
                <p>Wrap components to add functionality (legacy pattern).</p>
                
                <div class="code-block">
                    <code>
{`// HOC that adds authentication
function withAuth(WrappedComponent) {
  return function AuthenticatedComponent(props) {
    const { user } = useAuth();
    
    if (!user) {
      return &lt;LoginPrompt /&gt;;
    }
    
    return &lt;WrappedComponent {...props} /&gt;;
  };
}

// Usage
const AuthenticatedDashboard = withAuth(Dashboard);

// But prefer custom hooks for new code:
function Dashboard() {
  const { user } = useAuth();
  
  if (!user) return &lt;LoginPrompt /&gt;;
  
  return &lt;DashboardContent /&gt;;
}`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 7: Compound Components with Context</summary>
                <p>Combine compound components with context for powerful abstractions.</p>
                
                <div class="code-block">
                    <code>
{`// Create context
const AccordionContext = createContext({
  openIndex: null,
  toggle: () =&gt; {}
});

// Parent component
function Accordion({ children }) {
  const [openIndex, setOpenIndex] = useState(null);
  
  const toggle = (index) =&gt; {
    setOpenIndex(prev =&gt; prev === index ? null : index);
  };
  
  const value = { openIndex, toggle };
  
  return (
    &lt;AccordionContext.Provider value={value}&gt;
      {children}
    &lt;/AccordionContext.Provider&gt;
  );
}

// Child component
function AccordionItem({ title, children, index }) {
  const { openIndex, toggle } = useContext(AccordionContext);
  const isOpen = openIndex === index;
  
  return (
    &lt;div className="accordion-item"&gt;
      &lt;button 
        className="accordion-header" 
        onClick={() =&gt; toggle(index)}
      &gt;
        {title}
        &lt;span&gt;{isOpen ? '−' : '+'}&lt;/span&gt;
      &lt;/button&gt;
      {isOpen &amp;&amp; (
        &lt;div className="accordion-content"&gt;
          {children}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

// Usage
&lt;Accordion&gt;
  &lt;AccordionItem title="Section 1" index={0}&gt;
    &lt;p&gt;Content for section 1&lt;/p&gt;
  &lt;/AccordionItem&gt;
  &lt;AccordionItem title="Section 2" index={1}&gt;
    &lt;p&gt;Content for section 2&lt;/p&gt;
  &lt;/AccordionItem&gt;
&lt;/Accordion&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 8: Composition with Props</summary>
                <p>Use props to compose components dynamically.</p>
                
                <div class="code-block">
                    <code>
{`// Flexible card component
function Card({ 
  header, 
  footer, 
  children, 
  variant = 'default',
  className = '' 
}) {
  const variants = {
    default: 'bg-gray-100',
    primary: 'bg-blue-100',
    danger: 'bg-red-100'
  };
  
  return (
    &lt;div className={\`\${variants[variant]} \${className}\`}&gt;
      {header &amp;&amp; &lt;div className="card-header"&gt;{header}&lt;/div&gt;}
      {children &amp;&amp; &lt;div className="card-body"&gt;{children}&lt;/div&gt;}
      {footer &amp;&amp; &lt;div className="card-footer"&gt;{footer}&lt;/div&gt;}
    &lt;/div&gt;
  );
}

// Usage
&lt;Card 
  header={&lt;h2&gt;Title&lt;/h2&gt;} 
  footer={&lt;button&gt;Action&lt;/button&gt;}
  variant="primary"
&gt;
  &lt;p&gt;This is the main content.&lt;/p&gt;
&lt;/Card&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 9: Component Factory</summary>
                <p>Create components dynamically based on configuration.</p>
                
                <div class="code-block">
                    <code>
{`// Component factory
function createFormComponent(fields) {
  return function FormComponent({ onSubmit }) {
    const [values, setValues] = useState({});
    
    const handleChange = (field, value) =&gt; {
      setValues(prev =&gt; ({ ...prev, [field]: value }));
    };
    
    const handleSubmit = (e) =&gt; {
      e.preventDefault();
      onSubmit(values);
    };
    
    return (
      &lt;form onSubmit={handleSubmit}&gt;
        {fields.map(field =&gt; (
          &lt;div key={field.name}&gt;
            &lt;label htmlFor={field.name}&gt;{field.label}&lt;/label&gt;
            &lt;input 
              type={field.type || 'text'}
              id={field.name}
              name={field.name}
              value={values[field.name] || ''}
              onChange={(e) =&gt; handleChange(field.name, e.target.value)}
              placeholder={field.placeholder}
            /&gt;
          &lt;/div&gt;
        ))}
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
      &lt;/form&gt;
    );
  };
}

// Usage
const UserForm = createFormComponent([
  { name: 'firstName', label: 'First Name', placeholder: 'Enter first name' },
  { name: 'lastName', label: 'Last Name', placeholder: 'Enter last name' },
  { name: 'email', label: 'Email', type: 'email', placeholder: 'Enter email' }
]);

// Then use it like any other component
&lt;UserForm onSubmit={(values) =&gt; console.log('Submitted:', values)} /&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Pattern 10: Slot-Based Composition</summary>
                <p>Use children as slots for different parts of a component.</p>
                
                <div class="code-block">
                    <code>
{`// Modal with named slots
function Modal({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  
  const header = React.Children.toArray(children).find(
    child =&gt; child.type === Modal.Header
  );
  
  const body = React.Children.toArray(children).find(
    child =&gt; child.type === Modal.Body
  );
  
  const footer = React.Children.toArray(children).find(
    child =&gt; child.type === Modal.Footer
  );
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsOpen(true)}&gt;Open Modal&lt;/button&gt;
      
      {isOpen &amp;&amp; (
        &lt;div className="modal-overlay"&gt;
          &lt;div className="modal-content"&gt;
            {header}
            {body}
            {footer}
            &lt;button onClick={() =&gt; setIsOpen(false)}&gt;Close&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

Modal.Header = function ModalHeader({ children }) {
  return &lt;div className="modal-header"&gt;{children}&lt;/div&gt;;
};

Modal.Body = function ModalBody({ children }) {
  return &lt;div className="modal-body"&gt;{children}&lt;/div&gt;;
};

Modal.Footer = function ModalFooter({ children }) {
  return &lt;div className="modal-footer"&gt;{children}&lt;/div&gt;;
};

// Usage
&lt;Modal&gt;
  &lt;Modal.Header&gt;Confirm Action&lt;/Modal.Header&gt;
  &lt;Modal.Body&gt;
    &lt;p&gt;Are you sure you want to delete this item?&lt;/p&gt;
  &lt;/Modal.Body&gt;
  &lt;Modal.Footer&gt;
    &lt;button&gt;Cancel&lt;/button&gt;
    &lt;button&gt;Delete&lt;/button&gt;
  &lt;/Modal.Footer&gt;
&lt;/Modal&gt;`}
                    </code>
                </div>
            </details>

            <details>
                <summary>Composition Strategy Comparison</summary>
                <table class="table table-dark table-striped mt-3">
                    <thead>
                        <tr>
                            <th>Strategy</th>
                            <th>Best For</th>
                            <th>Complexity</th>
                            <th>Flexibility</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Layout Components</td>
                            <td>Page structure, consistent layouts</td>
                            <td>Low</td>
                            <td>Medium</td>
                        </tr>
                        <tr>
                            <td>Wrapper Components</td>
                            <td>Adding behavior (auth, loading, error)</td>
                            <td>Low-Medium</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td>Container Components</td>
                            <td>Separating data fetching from presentation</td>
                            <td>Low</td>
                            <td>Medium</td>
                        </tr>
                        <tr>
                            <td>Compound Components</td>
                            <td>Components that work together as a unit</td>
                            <td>Medium</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td>Render Props</td>
                            <td>Sharing behavior with flexible output</td>
                            <td>Medium</td>
                            <td>Very High</td>
                        </tr>
                        <tr>
                            <td>HOCs</td>
                            <td>Legacy code, advanced patterns</td>
                            <td>High</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td>Slot-Based</td>
                            <td>Complex components with multiple sections</td>
                            <td>Medium-High</td>
                            <td>Very High</td>
                        </tr>
                        <tr>
                            <td>Component Factory</td>
                            <td>Dynamic component generation</td>
                            <td>High</td>
                            <td>Very High</td>
                        </tr>
                    </tbody>
                </table>
            </details>

            <details>
                <summary>Choosing the Right Composition Strategy</summary>
                <p>Use this decision tree:</p>
                
                <ol>
                    <li><strong>Do you need to add behavior to an existing component?</strong> → Use wrapper components</li>
                    <li><strong>Do you want to separate data from presentation?</strong> → Use container components</li>
                    <li><strong>Do you have components that work together as a unit?</strong> → Use compound components</li>
                    <li><strong>Do you need flexible rendering based on data?</strong> → Use render props</li>
                    <li><strong>Do you have a complex component with multiple distinct sections?</strong> → Use slot-based composition</li>
                    <li><strong>Do you need to generate components dynamically?</strong> → Use component factories</li>
                    <li><strong>Is this a simple layout?</strong> → Use layout components</li>
                </ol>
                
                <div class="note">
                    <strong>Golden Rule:</strong> Start simple. Use the least complex pattern that solves your problem. You can always refactor to a more complex pattern later if needed.
                </div>
            </details>

            <details>
                <summary>Composition Best Practices</summary>
                <ol>
                    <li><strong>Keep it simple:</strong> Favor composition over inheritance</li>
                    <li><strong>Be consistent:</strong> Choose one pattern and stick with it in your codebase</li>
                    <li><strong>Document patterns:</strong> Make sure your team understands your composition strategies</li>
                    <li><strong>Test compositions:</strong> Test components in combination, not just in isolation</li>
                    <li><strong>Prefer hooks over HOCs:</strong> Use custom hooks for stateful logic</li>
                    <li><strong>Use children wisely:</strong> Leverage the children prop for maximum flexibility</li>
                    <li><strong>Think in components:</strong> Break problems into small, composable pieces</li>
                </ol>
                
                <div class="warning">
                    <strong>Final Thought:</strong> Mastering component composition is what separates good React developers from great ones. The ability to combine simple components into complex, maintainable UIs is the essence of React's power.
                </div>
            </details>
        </div>
    </div>

    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Expand/Collapse All Controls
        document.getElementById('expandAll').addEventListener('click', () => {
            document.querySelectorAll('details').forEach(detail => {
                detail.setAttribute('open', '');
            });
        });

        document.getElementById('collapseAll').addEventListener('click', () => {
            document.querySelectorAll('details').forEach(detail => {
                detail.removeAttribute('open');
            });
        });

        // Search functionality for TOC
        document.getElementById('searchToc').addEventListener('input', function(e) {
            const query = e.target.value.toLowerCase();
            const tocItems = document.querySelectorAll('.toc-item');
            
            tocItems.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(query)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        });

        // Smooth scrolling for TOC navigation
        document.querySelectorAll('.toc-item').forEach(item => {
            item.addEventListener('click', function() {
                const targetId = this.getAttribute('data-target');
                const targetElement = document.getElementById(targetId);
                
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 80,
                        behavior: 'smooth'
                    });
                    
                    // Highlight active item
                    document.querySelectorAll('.toc-item').forEach(el => el.classList.remove('active'));
                    this.classList.add('active');
                }
            });
        });

        // Highlight code snippets with simple syntax highlighting
        document.querySelectorAll('pre code').forEach(block => {
            // Simple syntax highlighting for JSX
            const content = block.textContent;
            
            // Highlight JSX tags
            let highlighted = content
                .replace(/(&lt;\/?)([a-zA-Z][a-zA-Z0-9]*)(&gt;)/g, '$1<span class="jsx-tag">$2</span>$3')
                .replace(/([a-zA-Z]+)=/g, '<span class="jsx-attr">$1</span>=')
                .replace(/=["'][^"']*["']/g, match => `<span class="jsx-value">${match}</span>`)
                .replace(/(true|false|null|undefined)/g, '<span class="keyword">$1</span>')
                .replace(/\/\/.*$/gm, match => `<span class="comment">${match}</span>`);
            
            block.innerHTML = highlighted;
        });

        // Initialize first section as active
        document.querySelector('.toc-item').classList.add('active');

        // Add smooth scroll to all anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    window.scrollTo({
                        top: targetElement.offsetTop - 80,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html>
