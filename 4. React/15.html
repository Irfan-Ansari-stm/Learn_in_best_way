
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>React Forms Deep Dive - Chapter 11</title>
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a192f;
      --cyan: #00f5ff;
      --amber: #ffb347;
      --text-light: #e6f1ff;
      --border-light: #1a3b5c;
    }

    body {
      background-color: var(--bg-dark);
      color: var(--text-light);
      font-family: 'Roboto', sans-serif;
      overflow-x: hidden;
    }

    .left-panel {
      position: fixed;
      width: 300px;
      height: 100vh;
      overflow-y: auto;
      padding: 20px;
      background-color: rgba(10, 25, 47, 0.9);
      border-right: 1px solid var(--border-light);
      z-index: 1000;
    }

    .right-panel {
      margin-left: 300px;
      padding: 30px;
      height: 100vh;
      overflow-y: auto;
      background-color: var(--bg-dark);
    }

    h1, h2, h3, h4 {
      color: var(--cyan);
      font-weight: 600;
    }

    h1 {
      border-bottom: 2px solid var(--amber);
      padding-bottom: 10px;
      margin-bottom: 25px;
    }

    h2 {
      margin-top: 40px;
      border-left: 4px solid var(--amber);
      padding-left: 15px;
    }

    h3 {
      color: var(--amber);
      margin-top: 30px;
    }

    .toc-item {
      margin: 8px 0;
      padding: 6px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .toc-item:hover {
      background-color: rgba(0, 245, 255, 0.1);
    }

    .toc-item.active {
      background-color: rgba(0, 245, 255, 0.2);
      border-left: 3px solid var(--cyan);
    }

    .search-box {
      margin-bottom: 20px;
      background-color: rgba(26, 59, 92, 0.5);
      border: 1px solid var(--border-light);
      color: var(--text-light);
    }

    .btn-control {
      background-color: rgba(10, 25, 47, 0.7);
      border: 1px solid var(--border-light);
      color: var(--cyan);
      margin-bottom: 15px;
      font-size: 0.9rem;
    }

    .btn-control:hover {
      background-color: rgba(0, 245, 255, 0.2);
      color: var(--cyan);
    }

    details {
      margin: 15px 0;
      border-left: 1px solid var(--border-light);
      padding-left: 15px;
      background-color: rgba(10, 25, 47, 0.4);
      border-radius: 0 5px 5px 0;
    }

    summary {
      list-style: none;
      cursor: pointer;
      font-weight: bold;
      color: var(--amber);
      padding: 10px 15px;
      background-color: rgba(0, 245, 255, 0.05);
      border-radius: 5px;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    summary::before {
      content: "‚ñ∂ ";
      font-size: 0.8em;
    }

    details[open] > summary::before {
      content: "‚ñº ";
    }

    pre {
      background-color: #0d1b2a !important;
      border: 1px solid var(--border-light);
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      margin: 15px 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    code {
      font-family: 'Roboto Mono', monospace;
      font-size: 0.95rem;
      color: var(--cyan);
    }

    .highlight {
      color: var(--amber);
      font-weight: bold;
    }

    .note {
      background-color: rgba(255, 179, 71, 0.1);
      border-left: 3px solid var(--amber);
      padding: 12px 15px;
      margin: 20px 0;
      border-radius: 0 5px 5px 0;
    }

    .syntax {
      background-color: rgba(0, 245, 255, 0.08);
      padding: 8px 12px;
      border-radius: 4px;
      font-weight: 500;
      display: inline-block;
      margin: 0 3px;
    }

    .author-info {
      color: var(--amber);
      font-style: italic;
      margin-top: 10px;
      font-size: 0.9rem;
    }

    .footer-note {
      margin-top: 60px;
      text-align: center;
      color: var(--amber);
      font-size: 0.85rem;
      border-top: 1px solid var(--border-light);
      padding-top: 15px;
    }

    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
    }

    /* Responsive adjustments */
    @media (max-width: 991px) {
      .left-panel {
        width: 100%;
        position: relative;
        height: auto;
        border-right: none;
        border-bottom: 1px solid var(--border-light);
      }
      .right-panel {
        margin-left: 0;
      }
    }

    /* Form styling for examples */
    .form-example {
      background-color: rgba(13, 27, 42, 0.6);
      padding: 20px;
      border-radius: 8px;
      border: 1px dashed var(--border-light);
      margin: 20px 0;
    }

    .form-control {
      background-color: #1a2b42 !important;
      border-color: var(--border-light) !important;
      color: var(--text-light) !important;
    }

    .form-control:focus {
      border-color: var(--cyan) !important;
      box-shadow: 0 0 0 0.2rem rgba(0, 245, 255, 0.25) !important;
    }

    .btn-primary {
      background-color: var(--amber);
      border-color: var(--amber);
    }

    .btn-primary:hover {
      background-color: #e6a23a;
      border-color: #e6a23a;
    }
  </style>
</head>
<body>

<div class="container-fluid p-0">
  <div class="row g-0">

    <!-- Left Panel -->
    <div class="col-md-3 left-panel">
      <h1>Chapter 11</h1>
      <h4>Forms in React</h4>
      <p class="author-info">‚Äî Mastering Input Handling with Clarity & Depth ‚Äî</p>

      <input type="text" class="form-control search-box" id="searchTOC" placeholder="Search topics..." />

      <div class="d-grid gap-2">
        <button class="btn btn-control" id="expandAll">Expand All</button>
        <button class="btn btn-control" id="collapseAll">Collapse All</button>
      </div>

      <div class="toc">
        <h5>Table of Contents</h5>
        <div class="toc-item" data-target="#section-11-1">11.1 Controlled Components Deep Dive</div>
        <div class="toc-item" data-target="#section-11-2">11.2 Uncontrolled Components with Refs</div>
        <div class="toc-item" data-target="#section-11-3">11.3 Form Libraries (Formik, React Hook Form)</div>
      </div>
    </div>

    <!-- Right Panel -->
    <div class="col-md-9 right-panel">

      <!-- Section 11.1 -->
      <section id="section-11-1">
        <h2>11.1 Controlled Components Deep Dive</h2>
        
        <details>
          <summary>üìå Summary: The Golden Rule of React Forms</summary>
          <p>Controlled components are the <span class="highlight">standard way</span> to handle forms in React. In a controlled component, form data is handled by React state ‚Äî meaning every input's value is tied to a state variable, and changes trigger state updates.</p>
          
          <h3>üîπ Core Concept: One-Way Data Flow</h3>
          <p>Think of it like a puppet master:</p>
          <ol>
            <li>React holds the <strong>source of truth</strong> (state)</li>
            <li>Input gets its value from state</li>
            <li>On change, React updates state</li>
            <li>React re-renders input with new value</li>
          </ol>

          <h3>‚ö° Syntax Example: Simple Text Input</h3>
          <pre><code>
import { useState } from 'react';

function NameForm() {
  const [name, setName] = useState('');

  const handleChange = (event) =&gt; {
    setName(event.target.value); // ‚Üê This is the magic!
  };

  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    alert('Submitted: ' + name);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Name:
        &lt;input 
          type="text" 
          value={name}           // ‚Üê Controlled by state
          onChange={handleChange} // ‚Üê Updates state on change
        /&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
  );
}
          </code></pre>

          <h3>üí° Why This Matters: Predictability</h3>
          <ul>
            <li>State is always synchronized with UI</li>
            <li>No DOM manipulation needed ‚Äî pure React!</li>
            <li>Easier to validate, reset, or conditionally render based on input</li>
          </ul>

          <div class="note">
            <strong>üß† Mental Model:</strong> A controlled input is like a mirror. The state is the real object. The input just reflects it. When you change the object, the mirror updates automatically.
          </div>
        </details>

        <details>
          <summary>üß™ Deep Dive: How React Handles Controlled Inputs Internally</summary>
          <p>When you use <code>value={state}</code>, React overrides the browser's native input behavior. Here's what happens under the hood:</p>

          <h3>Pseudocode: Behind the Scenes</h3>
          <pre><code>
// Simplified React internal logic for controlled inputs:
function updateInput(inputElement, newValue) {
  // Step 1: React checks if the new value differs from current DOM value
  if (inputElement.value !== newValue) {
    // Step 2: React forces the DOM to match state
    inputElement.value = newValue;
  }
  
  // Step 3: When user types, onChange fires ‚Üí triggers state update
  // Step 4: React re-renders ‚Üí goes back to Step 1
}
          </code></pre>

          <h3>‚ö†Ô∏è Common Pitfall: Forgetting `onChange`</h3>
          <pre><code>
// ‚ùå BAD: Input is "controlled" but not updated
function BadForm() {
  const [name, setName] = useState('');
  
  return (
    &lt;input type="text" value={name} /&gt; 
    // ‚Üê No onChange! User can't type anything!
  );
}

// ‚úÖ GOOD: Always pair value with onChange
function GoodForm() {
  const [name, setName] = useState('');
  
  return (
    &lt;input 
      type="text" 
      value={name} 
      onChange={(e) =&gt; setName(e.target.value)} 
    /&gt;
  );
}
          </code></pre>

          <h3>üî• Real-World Example: Multi-Field Form</h3>
          <pre><code>
import { useState } from 'react';

function RegistrationForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    age: '',
    agree: false
  });

  const handleChange = (e) =&gt; {
    const { name, value, type, checked } = e.target;
    setFormData(prev =&gt; ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    console.log('Form Data:', formData);
    alert('Registration successful!');
  };

  return (
    &lt;form onSubmit={handleSubmit} className="form-example"&gt;
      &lt;div className="mb-3"&gt;
        &lt;label className="form-label"&gt;Email&lt;/label&gt;
        &lt;input 
          type="email" 
          name="email" 
          value={formData.email} 
          onChange={handleChange} 
          className="form-control" 
          required 
        /&gt;
      &lt;/div&gt;

      &lt;div className="mb-3"&gt;
        &lt;label className="form-label"&gt;Password&lt;/label&gt;
        &lt;input 
          type="password" 
          name="password" 
          value={formData.password} 
          onChange={handleChange} 
          className="form-control" 
          minLength="8" 
          required 
        /&gt;
      &lt;/div&gt;

      &lt;div className="mb-3"&gt;
        &lt;label className="form-label"&gt;Age&lt;/label&gt;
        &lt;input 
          type="number" 
          name="age" 
          value={formData.age} 
          onChange={handleChange} 
          className="form-control" 
          min="13" 
        /&gt;
      &lt;/div&gt;

      &lt;div className="mb-3 form-check"&gt;
        &lt;input 
          type="checkbox" 
          name="agree" 
          checked={formData.agree} 
          onChange={handleChange} 
          className="form-check-input" 
        /&gt;
        &lt;label className="form-check-label"&gt;I agree to terms&lt;/label&gt;
      &lt;/div&gt;

      &lt;button type="submit" className="btn btn-primary"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}
          </code></pre>

          <h3>üí° Advanced Pattern: Custom Hooks for Forms</h3>
          <pre><code>
// Custom hook to abstract form logic
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);

  const handleChange = (e) =&gt; {
    const { name, value, type, checked } = e.target;
    setValues(prev =&gt; ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const reset = () =&gt; setValues(initialValues);

  return { values, handleChange, reset };
}

// Usage
function LoginForm() {
  const { values, handleChange, reset } = useForm({ email: '', password: '' });

  return (
    &lt;form&gt;
      &lt;input name="email" value={values.email} onChange={handleChange} /&gt;
      &lt;input name="password" value={values.password} onChange={handleChange} /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
      &lt;button type="button" onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/form&gt;
  );
}
          </code></pre>
        </details>
      </section>

      <!-- Section 11.2 -->
      <section id="section-11-2">
        <h2>11.2 Uncontrolled Components with Refs</h2>
        
        <details>
          <summary>üìå Summary: Let the Browser Handle It</summary>
          <p>Uncontrolled components store form data in the DOM itself, not in React state. You access values using <code>ref</code> ‚Äî a direct reference to the DOM element. Use them when you need to integrate with non-React libraries or optimize performance for very large forms.</p>

          <h3>üîπ Core Concept: DOM as Source of Truth</h3>
          <p>Unlike controlled components, here:</p>
          <ol>
            <li>Input has NO <code>value</code> prop</li>
            <li>React doesn't manage state</li>
            <li>You grab values directly from DOM using <code>useRef()</code></li>
          </ol>

          <h3>‚ö° Syntax Example: Simple Uncontrolled Input</h3>
          <pre><code>
import { useRef } from 'react';

function NameForm() {
  const nameInput = useRef(null);

  const handleSubmit = (event) =&gt; {
    event.preventDefault();
    // üëá Direct DOM access ‚Äî no state involved!
    alert('Submitted: ' + nameInput.current.value);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label&gt;
        Name:
        &lt;input 
          type="text" 
          ref={nameInput}     // ‚Üê Ref points to DOM element
          defaultValue="John" // ‚Üê Initial value (optional)
        /&gt;
      &lt;/label&gt;
      &lt;input type="submit" value="Submit" /&gt;
    &lt;/form&gt;
  );
}
          </code></pre>

          <h3>üí° Why Use Uncontrolled?</h3>
          <ul>
            <li><strong>Performance:</strong> No re-renders on every keystroke</li>
            <li><strong>Simplicity:</strong> Less boilerplate for simple cases</li>
            <li><strong>Legacy Integration:</strong> Works with jQuery plugins, third-party widgets</li>
          </ul>

          <div class="note">
            <strong>‚ö†Ô∏è Warning:</strong> Avoid uncontrolled components unless you have a specific reason. They break React‚Äôs declarative model and make testing harder.
          </div>
        </details>

        <details>
          <summary>üß™ Deep Dive: Refs vs State ‚Äî The Performance Tradeoff</summary>
          <p>Here‚Äôs what happens in each approach when typing ‚ÄúA‚Äù ‚Üí ‚ÄúB‚Äù ‚Üí ‚ÄúC‚Äù:</p>

          <h3>Controlled Component (Re-renders Every Time)</h3>
          <pre><code>
// Typing "A"
setState("A") ‚Üí Re-render ‚Üí Input displays "A"

// Typing "B"  
setState("AB") ‚Üí Re-render ‚Üí Input displays "AB"

// Typing "C"
setState("ABC") ‚Üí Re-render ‚Üí Input displays "ABC"
          </code></pre>

          <h3>Uncontrolled Component (No Re-renders)</h3>
          <pre><code>
// Typing "A" ‚Üí DOM updates directly (browser native)
// Typing "B" ‚Üí DOM updates directly
// Typing "C" ‚Üí DOM updates directly

// Only at submit time: read value via ref
alert(ref.current.value); // ‚Üí "ABC"
          </code></pre>

          <h3>üî• Real-World Example: File Upload</h3>
          <pre><code>
import { useRef } from 'react';

function ImageUploader() {
  const fileInput = useRef(null);

  const handleUpload = () =&gt; {
    const file = fileInput.current.files[0];
    if (!file) return alert('Please select a file');

    const reader = new FileReader();
    reader.onload = (e) =&gt; {
      console.log('File content:', e.target.result);
    };
    reader.readAsDataURL(file);
  };

  return (
    &lt;div className="form-example"&gt;
      &lt;input 
        type="file" 
        ref={fileInput} 
        accept="image/*" 
      /&gt;
      &lt;button 
        onClick={handleUpload} 
        className="btn btn-primary mt-2"
      &gt;
        Upload Image
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
          </code></pre>

          <h3>‚úÖ When to Use Uncontrolled</h3>
          <table class="table table-dark table-sm mt-3">
            <thead>
              <tr><th>Use Case</th><th>Recommended</th></tr>
            </thead>
            <tbody>
              <tr><td>Simple form with few fields</td><td>‚ùå Avoid</td></tr>
              <tr><td>Large form (100+ inputs)</td><td>‚úÖ Consider</td></tr>
              <tr><td>Integrating with non-React library</td><td>‚úÖ Yes</td></tr>
              <tr><td>File uploads</td><td>‚úÖ Yes</td></tr>
              <tr><td>Text areas with rich text editors</td><td>‚úÖ Sometimes</td></tr>
              <tr><td>Accessibility-sensitive apps</td><td>‚ùå Prefer controlled</td></tr>
            </tbody>
          </table>

          <h3>‚ö†Ô∏è Gotcha: Refs Don‚Äôt Trigger Re-renders</h3>
          <p>Since refs don‚Äôt cause re-renders, you can‚Äôt use them to conditionally render UI based on input values:</p>
          <pre><code>
function BadExample() {
  const input = useRef(null);

  // ‚ùå This won't re-render when input changes!
  return (
    &lt;div&gt;
      {input.current?.value.length &gt; 0 ? 
        &lt;p&gt;You typed something!&lt;/p&gt; : 
        null
      }
      &lt;input ref={input} /&gt;
    &lt;/div&gt;
  );
}
          </code></pre>

          <p>To fix this, you‚Äôd need to combine with state ‚Äî which defeats the purpose. So use uncontrolled only when you don‚Äôt need live feedback.</p>
        </details>
      </section>

      <!-- Section 11.3 -->
      <section id="section-11-3">
        <h2>11.3 Form Libraries (Formik, React Hook Form)</h2>
        
        <details>
          <summary>üìå Summary: Stop Writing Boilerplate ‚Äî Let Libraries Do the Work</summary>
          <p>While controlled components are powerful, writing validation, submission, and error handling manually becomes messy at scale. That‚Äôs where libraries like <span class="syntax">Formik</span> and <span class="syntax">React Hook Form</span> come in ‚Äî they give you superpowers without leaving React.</p>

          <h3>üîπ Key Differences at a Glance</h3>
          <table class="table table-dark table-sm mt-3">
            <thead>
              <tr><th>Feature</th><th>Formik</th><th>React Hook Form</th></tr>
            </thead>
            <tbody>
              <tr><td>State Management</td><td>Full form state</td><td>Minimal state (only touched/valid)</td></tr>
              <tr><td>Performance</td><td>Can re-render entire form</td><td>Optimized ‚Äî minimal re-renders</td></tr>
              <tr><td>Learning Curve</td><td>Moderate</td><td>Low</td></tr>
              <tr><td>Best For</td><td>Complex forms with nested data</td><td>Most forms ‚Äî especially performance-critical</td></tr>
              <tr><td>Validation</td><td>Yup schema or function</td><td>Zod/Yup or built-in HTML5</td></tr>
            </tbody>
          </table>

          <h3>‚ö° Example: Same Form in Both Libraries</h3>
          <h4>‚úÖ Using React Hook Form (Modern Standard)</h4>
          <pre><code>
import { useForm } from 'react-hook-form';

function LoginForm() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = (data) =&gt; {
    console.log(data); // { email: "test@example.com", password: "123" }
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;input 
          {...register('email', { 
            required: 'Email is required',
            pattern: {
              value: /^[^\\s@]+@[^\\s@]+\.[^\\s@]+$/,
              message: 'Invalid email'
            }
          })} 
          placeholder="Email" 
        /&gt;
        {errors.email &amp;&amp; &lt;span style={{color:'red'}}&gt;{errors.email.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;input 
          type="password" 
          {...register('password', { 
            required: 'Password is required',
            minLength: { value: 8, message: 'Min 8 chars' }
          })} 
          placeholder="Password" 
        /&gt;
        {errors.password &amp;&amp; &lt;span style={{color:'red'}}&gt;{errors.password.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}
          </code></pre>

          <h4>‚úÖ Using Formik</h4>
          <pre><code>
import { Formik, Form, Field, ErrorMessage } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object({
  email: Yup.string().email('Invalid email').required('Required'),
  password: Yup.string().min(8, 'Too short!').required('Required')
});

function LoginForm() {
  return (
    &lt;Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) =&gt; {
        console.log(values);
      }}
    &gt;
      {({ isSubmitting }) =&gt; (
        &lt;Form&gt;
          &lt;div&gt;
            &lt;Field 
              name="email" 
              type="email" 
              placeholder="Email" 
              className="form-control" 
            /&gt;
            &lt;ErrorMessage name="email" component="div" style={{color:'red'}} /&gt;
          &lt;/div&gt;

          &lt;div&gt;
            &lt;Field 
              name="password" 
              type="password" 
              placeholder="Password" 
              className="form-control" 
            /&gt;
            &lt;ErrorMessage name="password" component="div" style={{color:'red'}} /&gt;
          &lt;/div&gt;

          &lt;button type="submit" disabled={isSubmitting}&gt;Login&lt;/button&gt;
        &lt;/Form&gt;
      )}
    &lt;/Formik&gt;
  );
}
          </code></pre>

          <h3>üí° Why React Hook Form Wins Today</h3>
          <ul>
            <li><strong>No re-renders on every keystroke</strong> ‚Äî uses refs internally</li>
            <li><strong>Smaller bundle size</strong> (~4KB vs Formik‚Äôs ~12KB)</li>
            <li><strong>Native HTML validation</strong> works out of the box</li>
            <li><strong>Zero dependencies</strong> (except for validation libraries like Zod)</li>
          </ul>

          <h3>üöÄ Pro Tip: Combine with Zod for Type Safety</h3>
          <pre><code>
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

type LoginSchema = z.infer&lt;typeof loginSchema&gt;;

function LoginForm() {
  const { register, handleSubmit } = useForm({
    resolver: zodResolver(loginSchema)
  });

  const onSubmit = (data: LoginSchema) =&gt; {
    console.log(data); // TypeScript knows exact shape!
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;input {...register('email')} /&gt;
      &lt;input type="password" {...register('password')} /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}
          </code></pre>

          <h3>üéØ Decision Tree: Which Should You Use?</h3>
          <pre><code>
Is your form simple? (3-5 fields)         ‚Üí Use React Hook Form
Is your form complex? (nested objects, dynamic fields) ‚Üí Use React Hook Form + Zod
Are you using TypeScript?                 ‚Üí Use React Hook Form + Zod
Do you need drag-and-drop form builders?  ‚Üí Use Formik + Formik-UI
Are you maintaining legacy code?          ‚Üí Stick with what‚Äôs there
Are you learning?                         ‚Üí Master controlled components first!
          </code></pre>

          <div class="note">
            <strong>üåü Final Wisdom:</strong> Start with controlled components to understand the fundamentals. Then use React Hook Form for production apps. Formik is still great, but React Hook Form is now the modern standard.
          </div>
        </details>

        <details>
          <summary>‚öôÔ∏è Deep Dive: How React Hook Form Achieves Peak Performance</summary>
          <p>React Hook Form uses a brilliant trick: it never stores form values in React state. Instead, it uses <code>useRef()</code> to track values and <code>useEffect()</code> to register inputs dynamically.</p>

          <h3>Behind the Scenes Pseudocode</h3>
          <pre><code>
function useForm() {
  const registry = useRef(new Map()); // Stores all input refs
  const values = useRef({});         // Stores current values
  
  const register = (name, options) =&gt; {
    const input = document.querySelector(`[name="${name}"]`);
    registry.current.set(name, input);
    
    input.addEventListener('input', () =&gt; {
      values.current[name] = input.value; // ‚Üê Update ref, NOT state!
    });
    
    return { name }; // Return props to spread on input
  };

  const getValues = () =&gt; ({ ...values.current }); // Read from ref
  const handleSubmit = (onSubmit) =&gt; (e) =&gt; {
    e.preventDefault();
    onSubmit(getValues()); // ‚Üê Pass clean values
  };

  return { register, handleSubmit, ... };
}
          </code></pre>

          <p>This means: <strong>no unnecessary re-renders</strong>. Only the fields that change get updated. Your form stays snappy even with 50+ inputs.</p>
        </details>
      </section>

      <div class="footer-note">
        üìö Next: Form Validation Patterns, Async Submission, and Testing Forms in React
      </div>

    </div>
  </div>
</div>

<!-- JavaScript Utilities -->
<script>
  // Expand/Collapse All
  document.getElementById('expandAll').addEventListener('click', () => {
    document.querySelectorAll('details').forEach(detail => detail.open = true);
  });

  document.getElementById('collapseAll').addEventListener('click', () => {
    document.querySelectorAll('details').forEach(detail => detail.open = false);
  });

  // Smooth Scroll to TOC Item
  document.querySelectorAll('.toc-item').forEach(item => {
    item.addEventListener('click', () => {
      const targetId = item.getAttribute('data-target');
      document.querySelector(targetId).scrollIntoView({ behavior: 'smooth' });
      
      // Highlight active item
      document.querySelectorAll('.toc-item').forEach(el => el.classList.remove('active'));
      item.classList.add('active');
    });
  });

  // Search TOC
  document.getElementById('searchTOC').addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase();
    document.querySelectorAll('.toc-item').forEach(item => {
      const text = item.textContent.toLowerCase();
      item.style.display = text.includes(query) ? 'block' : 'none';
    });
  });

  // Optional: Add highlight.js if needed (uncomment if CDN available)
  /*
  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js';
  script.onload = () => {
    document.querySelectorAll('pre code').forEach(block => hljs.highlightBlock(block));
  };
  document.head.appendChild(script);
  */
</script>

<!-- Bootstrap JS Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

</body>
</html>
